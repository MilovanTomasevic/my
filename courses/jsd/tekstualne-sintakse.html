<!DOCTYPE html>
<html>

<head>
	<title>[Tekstualne sintakse](/courses/#table-of-contents)</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="../remarkslides.css">
	<!-- MathJaxâ„¢ -->
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
	</script>
	<!-- mermaid dijagram -->
	<link rel="stylesheet2" href="../mermaid.min.css">
	<script>
		mermaid.initialize({startOnLoad:true});
	</script>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127734928-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		      function gtag(){dataLayer.push(arguments);}
		      gtag('js', new Date());
		
		      gtag('config', 'UA-127734928-1');
	</script>
	<!-- google analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		      ga('create', 'UA-127734928-1', 'auto');
		      ga('send', 'pageview');
	</script>
</head>

<body>
	<textarea id="source">class: center, middle

## [Tekstualne sintakse](/courses/#table-of-contents)



.author[[dr. Milovan TomaÅ¡eviÄ‡](https://www.milovantomasevic.com/resume/)]

.small[[Fakulteta za informacijske Å¡tudije v Novem mestu (FIÅ )](https://www.fis.unm.si/en/)</br>![:scale 10%](../fis/fis.png) .small[ [ğŸŒâ™ milovan.tomasevic.fis.unm.si](http://milovan.tomasevic.fis.unm.si)</br> [ğŸ“§â™ milovan.tomasevic@fis.unm.si](mailto:milovan.tomasevic@fis.unm.si)]]



.created[08.03.2019 u 19:15]


---

name: sadrzaj

# SadrÅ¾aj

- [Parsiranje](#parsiranje)
- [Formalne gramatike](#formalne-gramatike)
- [Strategije parsiranja](#strategije-parsiranja)

---
name: pregled
class: center, middle, inverse

# Parsiranje

---
layout: true

.section[[Parsiranje](#sadrzaj)]

---

## JeziÄki softver (*Language Software*)

Osnovne klase alata:

- *Generators* - generiÅ¡u validne reÄenice na nekom jeziku.
- *Recognizers* - prepoznaju da li reÄenica pripada jeziku.
- *Parsers* - prevode reÄenice u stabla.
- *Formatters* - prevode stabla u reÄenice.

---

## Parsiranje - sintaksna analiza

- Analiza linearnog zapisa niza simbola na osnovu pravila neke formalne
  gramatike jezika.
- Transformacija ulaznog stringa u *stablo parsiranja* ili neku drugu strukturu
  podatka.

---

## LeksiÄka analiza

- Svaki jezik poseduje *alfabet moguÄ‡ih karaktera* koji se mogu pojaviti u
  sklopu validnih reÄenica. Kod raÄunarskih jezika odreÄ‘ene kombinacije simbola
  se tretiraju kao jedinstveni entitet - *token*.ref[1].
- *Proces grupisanja* niza uzastopnih karaktera ulaznog stringa u tokene.
  Tekstualni blok koji odgovara tokenu naziva se joÅ¡ i *leksema*.
- Program koji vrÅ¡i leksiÄku analizu naziva se *lekser*, *skener* ili
  *tokenizator*.
- LeksiÄka analiza *prethodi procesu parsiranja* tako Å¡to se karakteri sa ulaza
  prvo grupiÅ¡u u tokene a zatim parser vrÅ¡i sintaksnu analizu i kreira stablo
  parsiranja.
- Skeneri mogu biti posebni alati a mogu biti integrisani u parser (*scannerless
  parsing*).
- Poznatiji skeneri: flex i lex, JLex...

.footer[
1. A. Aho and J. Ullman, The theory of parsing, translation, and compiling, vol.
  1 of Series in Automatic Computation. Prentice-Hall, 1972
] 

---

## Stablo parsiranja

- Nastaje iz niske simbola (ulaznog stringa) procesom *skeniranja* (tokenizacije
  ili leksiÄke analize) i *parsiranja*.
- Listovi stabla su tokeni prepoznati od strane skenera (*terminali*) dok su
  unutraÅ¡nji Ävorovi stabla (*neterminali*) definisani gramatikom jezika.
- Stablo parsiranja reflektuje sintaksnu strukturu ulaznog stringa na bazi
  unapred definisane formalne gramatike.
  
---

## Stablo parsiranja - primer

![](tekstualne-sintakse/calc_parse_tree.svg)
.center[Stablo parsiranja za ulazni string `-(4-1)*5/(2+4.67)`]

---

## Stablo apstraktne sintakse

- Svaki iskaz na datom jeziku se moÅ¾e na apstraktan naÄin opisati stablom
  apstraktne sintakse (*Abstract Syntax Tree*).
- AST je usmereno labelirano stablo gde Ävorovi stabla predstavljaju instance
  koncepata apstraktne sintakse.
- AST ne sadrÅ¾i elemente koje ne doprinose semantici kao Å¡to su kljuÄne reÄi,
  zagrade, "prazni" karakteri i komentari.
  
---

## Primer stabla apstraktne sintakse

![](tekstualne-sintakse/AST.svg)
.center[`-(4-1)*5/(2+4.67)`]

---

## Razlike izmeÄ‘u stabla apstraktne i konkretne sintakse

- Stablo konkretne sintakse je bazirano na formalnoj gramatici koja opisuje
  *detalje zapisa* u tekstualnom obliku.
- Stablo apstraktne sintakse sadrÅ¾i *suÅ¡tinu jeziÄkog iskaza*.
- MoÅ¾emo imati viÅ¡e gramatika za isti jezik odnosno jedno stablo apstraktne
  sintakse moÅ¾emo zapisati na viÅ¡e razliÄitih naÄina Å¡to rezultuje razliÄitim
  stablima konkretne sintakse.
- Primer: Izraz `-(4-1)*5/(2+4.67)` moÅ¾emo u postfiksnoj notaciji (obrnuta
  poljska notacija) zapisati kao `4 1 - 5 * 2 4.67 + / -`. Ovo Ä‡e rezultovati
  razliÄitim stablima parsiranja ali je suÅ¡tina izraza ista i moÅ¾e rezultovati
  istim stablom apstraktne sintakse.

---
name: formalne-gramatike
class: center, middle, inverse
layout: false

# Formalne gramatike

---
layout: true

.section[[Formalne gramatike](#sadrzaj)]

---

## Formalna gramatika

- Predstavlja skup pravila (*produkcije*) pomoÄ‡u
  kojih je moguÄ‡e generisati sve *validne reÄenice* nekog jezika
  (*formalni jezik*) polazeÄ‡i od *startnog simbola*.
- DefiniÅ¡e koji od svih moguÄ‡ih nizova simbola u jeziku predstavljaju
  validne reÄenice tog jezika (ali bez validnosti njihovih znaÄenja).
- Generisanje ispravnih reÄenica jezika (*generativne gramatike*) - Äesto se
  koriste kao osnova za prepoznavanje validnih reÄenica.

---

## Formalna gramatika - definicija

Formalna gramatika je `G = (N, Î£, P, S)` gde je:

- `N` - konaÄni skup *neterminalnih simbola*,
- `Î£` - konaÄni skup *terminalnih simbola*,
- `P` - konaÄni skup *produkcionih pravila* (produkcija) oblika: <br/>
  `(Î£ âˆª N)âˆ— N(Î£ âˆª N)âˆ— â†’ (Î£ âˆª N)âˆ—`
- `S` - neterminal iz skupa N (S âˆˆ N) koga nazivamo *poÄetnim simbolom*.

---

## Klasifikacija formalnih gramatika po ÄŒomskom

Formalne gramatike se mogu klasifikovati prema hijerarhijskoj klasifikaciji
  Noama ÄŒomskog.ref[1]. Prema ovoj klasifikaciji gramatike mogu biti:

  - *tipa 3 - rekurzivno prebrojive* - bez ograniÄenja na oblik
      produkcija.
  - *tipa 2 - kontekstno zavisne* - produkcije oblika: `Î±AÎ² â†’ Î±Î³Î²`
  - *tipa 1 - kontekstno slobodne* - produkcije oblika: `A â†’ Î³`
  - *tipa 0 - regularne* - produkcije oblika: `A â†’ a, A â†’ aB`

.footer[
  1. http://en.wikipedia.org/wiki/Chomsky_hierarchy
]

---

## Konteksno slobodne gramatike (*Context-Free Grammars - CFGs*)

- Produkcije oblika: `A â†’ Î³`
- Popularne u domenu raÄunarskih jezika. Dovoljno jednostavne za konstrukciju
  *efikasnih algoritama za parsiranje*.
- GeneriÅ¡u jezike koje nazivamo kontekstno slobodnim jezicima.
- *Earley parser* - algoritam za parsiranje koji prihvata ceo skup CFG. U praksi
  se ÄeÅ¡Ä‡e koriste jednostavniji algoritmi koji prihvataju samo podskup CFG.
- Jezik za definisanje CFG - *(Extended) Backus-Naur Form (EBNF)*.

---

## Primer kontekstno slobodne gramatike

```
G = ({S}, {a, b}, P, S)

S â†’ aSa
S â†’ bSb
S â†’ Îµ

```

.footer[
https://en.wikipedia.org/wiki/Context-free_grammar
]

---

## IzvoÄ‘enje - derivacija (*Derivation*)

- Generisanje ispravne reÄenice, poÄevÅ¡i od startnog simbola/neterminala,
  sukcesivnom primenom produkcija dok ne dobijemo reÄenicu koja se sastoji samo
  od terminala.

```
S â†’ aSa    (1)
S â†’ bSb    (2)
S â†’ Îµ      (3)

S (1)â†’ aSa (1)â†’ aaSaa (2)â†’ aabSbaa  (3)â†’ aabbaa
```

.footer[
https://en.wikipedia.org/wiki/Context-free_grammar
]

---

## Primer izvoÄ‘enja - alebarski izrazi

.lcol-narrow2[
```
1. S â†’ x
2. S â†’ y
3. S â†’ z
4. S â†’ S + S
5. S â†’ S - S
6. S â†’ S * S
7. S â†’ S / S
8. S â†’ ( S )
```
]

.rcol-wide2[
```
S (startni simbol)
â†’ S - S (pravilo 5)
â†’ S * S - S (pravilo 6, primenjeno na levi neterminal S)
â†’ S * S - S / S (pravilo 7, primenjeno na desni neterminal S)
â†’ ( S ) * S - S / S (pravilo 8, primenjeno na levi S)
â†’ ( S ) * S - S / ( S ) (pravilo 8, primenjeno na desni S)
â†’ ( S + S ) * S - S / ( S ) (itd.)
â†’ ( S + S ) * S - S * S / ( S )
â†’ ( S + S ) * S - S * S / ( S + S )
â†’ ( x + S ) * S - S * S / ( S + S )
â†’ ( x + y ) * S - S * S / ( S + S )
â†’ ( x + y ) * x - S * y / ( S + S )
â†’ ( x + y ) * x - S * y / ( x + S )
â†’ ( x + y ) * x - z * y / ( x + S )
â†’ ( x + y ) * x - z * y / ( x + x )
```
]

.footer[
https://en.wikipedia.org/wiki/Context-free_grammar
]
            

---

## ReÄeniÄna forma i reÄenica

- Bilo koja niska terminala i neterminala koja se moÅ¾e dobiti primenom
  produkcionih pravila poÄevÅ¡i od poÄetnog simbola naziva se reÄeniÄnom formom
  (*Sentential Form*).

```
( x + S ) * S - S * S / ( S + S )
```

- Ukoliko se reÄeniÄna forma sastoji samo od terminala onda je to reÄenica
  (*Sentence*).

```
( x + y ) * x - z * y / ( x + x )
```

---

## Odluke pri izvoÄ‘enju

- U svakom koraku izvoÄ‘enja parser donosi dve odluke:

  1. *koji neterminal da zameni?*,
  2. *sa kojim pravilom da ga zameni?* - ukoliko imamo viÅ¡e moguÄ‡nosti.

- Prva odluka je najÄeÅ¡Ä‡e fiksna (npr. uvek se zamenjuje prvi sleva ili prvi
  sdesna).
- Za drugu odluku koriste se tehnike kao Å¡to su *lookahead* (videti u nastavku).
- Strategija pri donoÅ¡enju druge odluke utiÄe na izgled stabla parsiranja.

---

## Strategije izvoÄ‘enja sa stanoviÅ¡ta izbora neterminala za zamenu

- *Levo izvoÄ‘enje* - uvek se prvo razreÅ¡ava levi neterminal.
- *Desno izvoÄ‘enje* - uvek se prvo razreÅ¡ava desni neterminal.
- Strategija izvoÄ‘enja je bitna kod parsera koji izvÅ¡avaju odreÄ‘ene akcije kod
  svake primene produkcije jer se redosled primene razlikuje iako mogu
  rezultovati istim stablima parsiranja.
  
---

## Levo izvoÄ‘enje - primer

![](tekstualne-sintakse/LeftDerivation.svg)

---

## ViÅ¡eznaÄne gramatike - primer - *dangling else*

.medium[
- Stablo parsiranja za odreÄ‘eni ulaz nije jednoznaÄno odreÄ‘eno CFG gramatikom
- ViÅ¡eznaÄna gramatika je gramatika kod koje postoji ulazni string sa viÅ¡e
  razliÄitih levih izvoÄ‘enja.
- Ili jednostavnije: ukoliko postoji ulazni string koji moÅ¾e da rezultuje sa
  viÅ¡e razliÄitih stabala parsiranja.
- KlasiÄan primer je "viseÄ‡i else":

```
if a then if b then s else s2
MoÅ¾e da se parsira kao:
if a then (if b then s) else s2
ili kao:
if a then (if b then s else s2)
```
- ReÅ¡avaju se dodavanjem pravila prioriteta ili dodavanjem konteksta kojim se
  izbegava viÅ¡eznaÄnost. Na primer, za kod `if-else` klauzule moÅ¾e se dodati
  kljuÄna reÄ `endif`.
]

---

## ViÅ¡eznaÄna gramatika - primer

![](tekstualne-sintakse/Ambiguous.svg)

---

## A u ovom sluÄaju Å¾elimo

.center[Stablo koje oslikava prioritet i asocijativnost operacija]

![:scale 80%](tekstualne-sintakse/Ambiguous2.svg)

---

## RazreÅ¡avanje viÅ¡eznaÄnosti

- ViÅ¡eznaÄnost je uglavnom *osobina gramatike a ne jezika*.
- ÄŒesto se gramatika moÅ¾e refaktorisati da ne bude viÅ¡eznaÄna.
- OdreÄ‘eni parseri omoguÄ‡avaju dodatna pravila (npr. *pravilo prioriteta*) koje
  pomaÅ¾e u izboru produkcije koju treba primeniti.
- Parser generatori Ä‡e najÄeÅ¡Ä‡e detektovati viÅ¡eznaÄnost i prijaviti greÅ¡ku.
- Generalizovani parseri dozvoljavaju viÅ¡eznaÄne gramatike. Ukoliko postoje
  razliÄite interpretacije ulaza biÄ‡e vraÄ‡ena sva moguÄ‡a stabla/interpretacije.
- Pojedini parseri implicitno razreÅ¡avaju viÅ¡eznaÄnost. Npr. rekurzivni silazni
  parseri (videti u nastavku) uvek pokuÅ¡avaju primenu produkcija po redosledu
  navoÄ‘enja (s leva na desno).

---

## Leva rekurzija

- OdreÄ‘ene vrste parsera ne smeju da imaju *levo rekurzivne produkcije* jer to
  dovodi do beskonaÄne rekurzije gde parser primenjuje stalno iste produkcije
  bez konzumiranja tokena sa ulaza.
- Mogu biti direktne i indirektne.
- Direktna leva rekurzija je produkcija oblika `A â†’ AÎ³`.
- Leve rekurzije se *mogu refaktorisati* da koriste desno rekurzivne produkcije
  ali gramatika tada Äesto gubi na intuitivnosti.

---

## Eliminacija leve rekurzije u opÅ¡tem sluÄaju
Pravilo `A â†’ Aa | B` postaje `A â†’ Ba*`

Primer:

```
expr â†’ expr '+' term | number

postaje:

expr â†’ number ('+' term)*
```

---

## *Extended Backusâ€“Naur Form - EBNF*

- Meta-sintaksa za zapis kontekstno slobodnih gramatika.
- ISO/IEC 14977
- Produkcije dodeljuju sekvencu simbola (terminala i neterminala) neterminalima.
- U Å¡irokoj upotrebi kod parser generatora i interpretera za opis gramatike
  jezika.
  
---

## Primer - EBNF u EBNF-u

.medium[
```
letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
symbol = "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"
       | "'" | '"' | "=" | "|" | "." | "," | ";" ;
character = letter | digit | symbol | "_" ;

identifier = letter , { letter | digit | "_" } ;
terminal = "'" , character , { character } , "'"
         | '"' , character , { character } , '"' ;

lhs = identifier ;
rhs = identifier
     | terminal
     | "[" , rhs , "]"
     | "{" , rhs , "}"
     | "(" , rhs , ")"
     | rhs , "|" , rhs
     | rhs , "," , rhs ;

rule = lhs , "=" , rhs , ";" ;
grammar = { rule } ;
```
]

.footer[
http://en.wikipedia.org/wiki/Extended_Backus-Naur_Form
]

---
name: strategije-parsiranja
class: center, middle, inverse
layout: false

# Strategije parsiranja

---
layout: true

.section[[Strategije parsiranja](#sadrzaj)]

---

## Strategije parsiranja

.medium[
- **Top-down (Silazna)**

  - KreÄ‡e od polaznog neterminala gramatike i pokuÅ¡ava da generiÅ¡e(izvede)
    ulazni string primenom produkcija *s leva na desno (lhs -> rhs)*.
  - Od opÅ¡teg ka pojedinaÄnom.
  - Ukoliko se izabere pogreÅ¡na alternativa radi se vraÄ‡anje - *backtrack*.
  - Ukoliko ne koriste vraÄ‡anje zovu se *prediktivni parseri*.
  - LL parseri i rekurzivni silazni parseri (*recursive descent*) koriste ovu
    strategiju.
  - LL parseri prirodno primenjuju levo izvoÄ‘enje stabla parsiranja.

- **Bottom-up (Uzlazna)**

  - KreÄ‡e od terminala i primenom produkcija *s desna na levo (lhs <- rhs)*
    pokuÅ¡ava da redukuje ulaz na polazni neterminal gramatike.
  - Od pojedinaÄnog ka opÅ¡tem.
  - *Shift-Reduce* - efikasan metod uzlaznog parsiranja.
  - LR parseri koriste ovu strategiju.
  - LR parseri prirodno primenjuju desno izvoÄ‘enje stabala parsiranja

]
            
---

## Lookahead

- Strategija kod koje se koristi odreÄ‘eni broj nekonzumiranih tokena sa ulaza da
  bi se odluÄilo o sledeÄ‡im koracima kod parsiranja.
- Manji *lookahead* znaÄi jednostavniji parser ali takoÄ‘e i manji skup gramatika
  koje prihvata.
- Koliko tokena unapred koristimo najÄeÅ¡Ä‡e piÅ¡e u oznaci parsera - primer LL(1),
  LR(k).
- Za veÄ‡inu programskih jezika potreban je samo jedan token *lookahead*-a -
  LL(1), LR(1)...
  
---

## VraÄ‡anje (*backtracking*)

- Strategija kod koje se u sluÄaju alternativnih derivacija pokuÅ¡ava redom sa
  svakom i u sluÄaju da parsiranje ne uspe *vrÅ¡i vraÄ‡anje unazad* (na
  stanje izbora alternative) i pokuÅ¡ava se sa sledeÄ‡om alternativom.
- Parseri koji implementiraju vraÄ‡anje Äesto prihvataju veÄ‡i skup gramatika tj.
  manja su ograniÄenja gramatika koje se prihvataju.
- Mana je Å¡to u praksi moÅ¾emo imati veliki broj alternativa Å¡to Äesto dovodi do
  *eksponencijalnog vremena parsiranja*.
- Ukoliko ne koriste vraÄ‡anje (prediktivni parseri) prihvataju manji skup
  gramatika.
  
---

## LL parser

- Top-down parser koji podrÅ¾ava podskup kontekstno slobodnih gramatika.
- Konzumira tokene s leva na desno i kreira levo izvoÄ‘enje.
- Klasa gramatika koju podÅ¾ava LL parser nazivamo LL gramatikama.
- LL(k) parser koristi k tokena unapred (*lookahead*) za odluku koju
  sledeÄ‡u produkciju da primeni. Ako takav parser postoji za neku gramatiku, a
  da ne koristi vraÄ‡anje (*backtracking*) tada kaÅ¾emo da je gramatika
  LL(k). Jezik za koji postoji LL(k) gramatika naziva se LL(k) jezik.
- LL(*) parseri nisu ograniÄeni na broj tokena koje mogu preuzeti sa ulaza da bi
  odluÄili o sledeÄ‡oj produkciji - dinamiÄki se prilagoÄ‘avaju.
- VeÄ‡e k - moÄ‡niji ali i sloÅ¾eniji parser. LL(1) su naroÄito popularni kod
  raÄunarskih jezika.
  
---

## Primer LL parsiranja

```
Gramatika: S â†’ E    E â†’ T + E    E â†’ T    T â†’ int
Ulaz: int + int + int

Production       Input              Action
---------------------------------------------------------
S                int + int + int    Predict S -&gt; E
E                int + int + int    Predict E -&gt; T + E
T + E            int + int + int    Predict T -&gt; int
int + E          int + int + int    Match int
+ E              + int + int        Match +
E                int + int          Predict E -&gt; T + E
T + E            int + int          Predict T -&gt; int
int + E          int + int          Match int
+ E              + int              Match +
E                int                Predict E -&gt; T
T                int                Predict T -&gt; int
int              int                Match int
                                    Accept
```
          
.footer[
http://stackoverflow.com/questions/5975741/what-is-the-difference-between-ll-and-lr-parsing
]

---

## LR parser

- Bottom-up parser koji podrÅ¾ava podskup kontekstno slobodnih gramatika.
- Implementiraju *Shift-Reduce* strategiju i koriste tablice stanja-prelaza.
  Skup gramatika koje prihvata je nadskup skupa koje prihvata prediktivni LL
  parser.
- 1965 Donald Knuth.
- Gramatika uglavnom ne mora da se prilagoÄ‘ava kao kod LL parsera. Mogu se
  navoditi rekurzivne produkcije.
- Podvarijante: LALR (*Look-Ahead*), SLR (*Simple*), GLR (*Generalized LR*).
- Generatori: yacc, GNU Bison, Elkhound...
- Interpreteri: parglare

---

## LR parsiranje - primer

![](tekstualne-sintakse/LR-Primer.png)

.footer[
http://www.dabeaz.com/ply/ply.html#ply_nn22
]

---

## GLR

- **G**eneralized **LR** parser.
- Parsiranje viÅ¡eznaÄnih gramatika.
- Efektivno radi kao LR parser ali u svakom stanju dozvoljava dozvoljava viÅ¡e
  prelaza Äime simulira nedeterministiÄki algoritam.
- Kod viÅ¡eznaÄnih ulaza vraÄ‡a skup stabala parsiranja (Å¡umu parsiranja - *Parse
  Forest*).
- Na korisniku je da odredi ispravno stablo - najÄeÅ¡Ä‡e dodatnim pravilima (npr.
  prioritet, asocijativnost).
- Bison u novijim verzijama moÅ¾e da generiÅ¡e GLR parser.
- SDF parser, Elkhound, DParser, parglare.

---

## LL - LR napomene

- Kod LL parsera problem je odreÄ‘ivanje produkcije koju treba primeniti nad
  neterminalom.
- Kod veÄ‡ine LR parsera (implementiranih kao SHIFT-REDUCE) problem je kada
  uraditi REDUCE operaciju i na koji neterminal redukovati, odnosno kada uraditi
  SHIFT.
- I kod jednog i kod drugog algoritma generiÅ¡e se tablica koja pomaÅ¾e parseru da
  donese odluku u toku parsiranja.
  
---

## Rekurzivni silazni parser - Recursive descent parser

- Silazni parser izgraÄ‘en na bazi meÄ‘usobno rekurzivnih procedura.
- Svaka procedura implementira jednu produkciju odnosno prepoznvanje jednog
  (ne)terminala.
- Kod prediktivnih parsera ne zahteva se vraÄ‡anje (*backtracking*).
- Ukoliko se koristi vraÄ‡anje vreme parsiranja *moÅ¾e eksponencijalno da
  poraste* kod sloÅ¾enijih gramatika.
  
---

## *Top-Down Parsing Language*

.medium[
- Å ematski opis rekurzivnog silaznog parsera sa vraÄ‡anjem (*recursive descent
  parser with backtracking*). Orijentisan je ka prepoznavanju ulaznog teksta.
- Ideje datiraju unazad u â€™70 godine proÅ¡log veka.ref[1,2].
- Rekurzivni silazni parseri nisu imali veÄ‡u popularnost u 20. veku jer vreme
  parsiranja moÅ¾e biti eksponencijalno ukoliko se ne koristi tehnika
  *memoizacije* u kom sluÄaju je linearno ali je potreban znaÄajan memorijski
  prostor koji direktno zavisi od veliÄine ulaza.
- Bryan Ford je obnovio interesovanje za TDPL (*Top-Down Parsing Language*)
  fomalizam za opis gramatika.ref[3].
- Gramatike koje opisuju TDPL Ford naziva gramatikama izraza za parsiranje
  (*Parsing Expression Grammars - PEG*).
]

.footer.small[
1. A. Birman, The tmg recognition schema. PhD thesis, 1970
2. A. Aho and J. Ullman, The theory of parsing, translation, and compiling, vol.
   1 of Series in Automatic Computation. Prentice-Hall, 1972
3. B. Ford, Packrat parsing: a practical linear-time algorithm with
   backtracking. PhD thesis, Massachusetts Institute of Technology, 2002
]

---

## PEG - *Parsing Expression Grammars*

- Formalizam za opis TDPL.
- Osnovna prednost PEG gramatika u odnosu na CFG jeste upotreba operatora
  ureÄ‘enog izbora (eng. *ordered choice*) koji omoguÄ‡ava nedvosmislenost u
  parsiranju.
- Ako ulazni tekst pripada jeziku koji opisuje dati PEG tada postoji samo jedno
  validno stablo koje ga opisuje.
- Odnosno, gramatike *ne mogu biti viÅ¡eznaÄne*.
- Kod CFG postoji neodreÄ‘enost jer je redosled izbora alternativa neodreÄ‘en i u
  praktiÄnim primenama zavisi od koriÅ¡Ä‡enog algoritma u implementaciji parsera.
- Vrsta parsera koja koristi PEG i implementirana je kao rekurzivni silazni
  parser sa bektrekingom i memoizacijom naziva se *pakrat parser*.

---

## Packrat parser

- Rekurzivni silazni parser sa vraÄ‡anjem koji koristi tehniku *memoizacije*
  (pamÄ‡enje derivacija podstabala) da bi obezbedio *linearno vreme
  izvrÅ¡avanja*.
- Prepoznaje bilo koji LL(k)/LR(k) jezik kao i mnoge jezike koji zahtevaju
  neograniÄen lookahead.
- Bolje kompozitne osobine od LL/LR parsera Å¡to ga Äini pogodnim za opis
  proÅ¡irivih dinamiÄkih jezika.

---

## Refaktorisanje gramatike za PEG parsere

![](tekstualne-sintakse/PEGPrioritet.svg)
.center[Kako enkodovati pravila prioriteta i eliminisati levu rekurziju?]

---

## DeterministiÄko parsiranje

- Algoritam parsiranja kod koga se ne koristi vraÄ‡anje unazad
  (*backtracking*).
- Analogno deterministiÄkom potisnom automatu.
- Parseri prihvataju klasu deterministiÄkih kontekstno slobodnih jezika (podskup
  svih kontekstno slobodnih jezika).
- Linearno vreme parsiranja - popularni u praksi.

---

## Pristupi u izradi parsera

- Parser generatori
- Interpreteri gramatika

---

## Parser generatori

- Na osnovu formalne gramatike *generiÅ¡u programski kod* parsera koji Ä‡e
  prepoznavati reÄenice na datom jeziku i pretvarati ulazne stringove u stabla
  parsiranja.
- ÄŒesto implementiraju mehanizam za obilazak stabla parsiranja i njegovu
  transformaciju.
- Mogu generisati i *lexer (scanner)* a mogu biti i *scannerless*.
- Neki od poznatijih parser generatora: ANTLR, JavaCC, yacc, bison.

---

## ANTLR

- ANTLR (*ANother Tool for Language Recognition*) je LL(*) parser generator
  implementiran na programskom jeziku Java.
- Iz opisa gramatike kreira parser kao i infrastrukturu za analizu stabla
  (vizitori, akcije koje se izvrÅ¡avaju kada se prepozna odreÄ‘ena konstrukcija).
  
---

## Interpreteri

- KonfiguriÅ¡u se gramatikom u vreme izvrÅ¡avanja (*run-time*) tj. *interpretiraju
  gramatiku*.
- Brz round-trip. Nema generisanja parsera. MoguÄ‡a izmena gramatike "u letu".
- Arpeggio, parglare i textX rade kao interpreteri.

--

class: center, middle, theend, hide-text
layout: false
background-image: url(../theend.gif)

</textarea>
	<script src="../remark-latest.min.js"></script>
	<script>
		// https://github.com/gnab/remark/issues/72
		        remark.macros.scale = function (percentage) {
		            var url = this;
		            return '<div class="center"><img src="'
		                 + url + '" style="width: ' + percentage + '" /></div>';
		        };
		        var slideshow = remark.create({
		                    highlightLanguage: 'python',
		                    // highlightStyle: 'obsidian',
		                    highlightStyle: 'github',
		                    highlightLines: true,
		                    countIncrementalSlides: false,
		                    navigation: {
		                      // Enable or disable navigating using scroll
		                      // Default: true
		                      // Alternatives: false
		                      scroll: false,
		
		                      //click: true,
		                    }
		                });
	</script>
	<script src="../mermaid.min.js"></script>
	<script>
		mermaid.initialize({startOnLoad:true});
	</script></body>

</html>