<!DOCTYPE html>
<html>

<head>
	<title>[Git](/courses/#table-of-contents)</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="../remarkslides.css">
	<!-- MathJaxâ„¢ -->
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
	</script>
	<!-- mermaid dijagram -->
	<link rel="stylesheet2" href="../mermaid.min.css">
	<script>
		mermaid.initialize({startOnLoad:true});
	</script>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127734928-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		      function gtag(){dataLayer.push(arguments);}
		      gtag('js', new Date());
		
		      gtag('config', 'UA-127734928-1');
	</script>
	<!-- google analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		      ga('create', 'UA-127734928-1', 'auto');
		      ga('send', 'pageview');
	</script>
</head>

<body>
	<textarea id="source">class: center, middle

## [Git](/courses/#table-of-contents)



.author[[dr. Milovan TomaÅ¡eviÄ‡](https://milovantomasevic.com/resume/)]

.small[[Fakulteta za informacijske Å¡tudije v Novem mestu (FIÅ )](https://www.fis.unm.si/en/)</br>![:scale 10%](../fis/fis.png) .small[ [ğŸŒâ™ milovan.tomasevic.fis.unm.si](http://milovan.tomasevic.fis.unm.si)</br> [ğŸ“§â™ milovan.tomasevic@fis.unm.si](mailto:milovan.tomasevic@fis.unm.si)]]



.created[08.03.2019 u 19:46]


---


name: sadrzaj

# SadrÅ¾aj

- [Uvod](#uvod)
- [Git repozitorijum](#repozitorijum)
- [Instalacija i konfiguracija](#konfiguracija)
- [Osnovne operacije](#operacije)
- [Grane](#grane)
- [Spajanje grana (*Merging*)](#merging)
- [Razmena promena](#razmena)
- [Ispravke greÅ¡aka](#greske)
- [OdrÅ¾avanje repozitorijuma](#odrzavanje)
- [Modeli grananja](#modeli)
- [PreporuÄena praksa](#praksa)
- [O implementaciji](#implementacija)
          
---
name: uvod
class: center, middle, inverse

# Uvod u Git

---
layout: true

.section[[Uvod](#sadrzaj)]

---

## Å ta je Git?
            
- Distribuirani sistem za kontrolu verzija (*Distributed Version Control System -
  DVCS*).
- Razvoj zapoÄeo Linus Torvalds, u aprilu 2005. godine, posle promene politike
  licenciranja BitKeeper-a koji je do tada koriÅ¡Ä‡en za razvoj linux kernela.
  Dostupan na adresi http://git-scm.com/
            
---

## Git - osobine
            
- Izuzetno brz i skalabilan.
- Jednostavan dizajn.
- VeÄ‡ina operacija su lokalne prirode.
- OdliÄna podrÅ¡ka za nelinearan razvoj (podrÅ¡ka za veliki broj grana) i velike
  projekte (npr. Linux kernel).
- Pisan najveÄ‡im delom u C-u, ali su delovi pisani u Perl-u, bash-u itd.
- Komande niskog nivoa (*plumbing*). Komande visokog nivoa (*porcelain*).
- Ne prati fajlove veÄ‡ sadrÅ¾aj. Izmene se eksplicitno dodaju pre *commit*-a.
- Kriptografska autentikacija istorije promena.
            
---

## Osnovni workflow

- Ako ne postoji klon repozitorijuma na lokalnom raÄunaru vrÅ¡i se kloniranje
  udaljenog repozitorijuma (ovo se generalno radi jednom).
- Menjaju se fajlovi.
- Izmene se dodaju u pripremnu zonu (indeks).
- VrÅ¡i se trajno beleÅ¾enje promene (operacija *commit*).

---
name: repozitorijum
layout: false
class: center, middle, inverse

# Git repozitorijum

---
layout: true

.section[[Repozitorijum](#sadrzaj)]

---

## PraÄ‡enje sadrÅ¾aja

Osnova git repozitorijuma je praÄ‡enje sadrÅ¾aja a ne fajlova i promena nad njima.
Informacije o promenama se izraÄunavaju po potrebi.

> Iâ€™m right. Iâ€™m always right, but sometimes Iâ€™m more right than
> other times. And dammit, when I say "files donâ€™t matter", Iâ€™m
> really really Right(tm).ref[1].

.footer[
    1. Linus
       Torvalds,
       [prepiska na mailing listi](http://article.gmane.org/gmane.comp.version-control.git/217) ]

---

## Veza radnog stabla, indeksa i repozitorijuma
![:scale 80%](git/Workflow.svg)

---

## Å½ivotni ciklus fajla u git repozitorijumu
![:scale 80%](git/FileLifecycle.svg)

---

## Git repozitorijum

- **Objektna baza**: Jednostavan model repozitorijuma baziran na mapama (parovi
  kljuÄ-vrednost).
- KljuÄevi su **SHA1 heÅ¡ sadrÅ¾aja** koji se Äuva + hedera.
- **Tri vrste objekata/vrednosti**. SadrÅ¾aj se komprimuje pomoÄ‡u *zlib* biblioteke.
- Reference - *pokazivaÄi* na odreÄ‘ene objekte u repozitorijumu.
- Repozitorijum se nalazi u **.git** direktorijumu unutar direktorijuma gde je
    izvrÅ¡ena inicijalizacija sa `git init` komandom (videti u nastavku).

---

## Git repozitorijum sa objektima i referencama

![Git repozitorijum sa objektima i referencama](git/git-repo.svg)

---

## Prikaz popularnih hosting reÅ¡enja

- https://github.com/
- https://gitlab.com/

---
name: konfiguracija
layout: false
class: center, middle, inverse

# Instalacija i konfiguracija

---
layout: true

.section[[Konfiguracija](#konfiguracija)]

---

## Vrste klijenata

- GUI
  - FLOSS: EGit (Eclipse plugin), git-cola, TortoiseGit, Git Extensions...
  - Komercijalni: SmartGit

- Command line - kanoniÄki git klijent

---

## PomoÄ‡ - help

Spisak osnovnih komandi git-a se moÅ¾e dobiti sa:

```
$ git help
usage: git [â€“version] ...
...
The most commonly used git commands are:
add       Add file contents to the index
bisect    Find by binary search the change that introduced a bug
branch    List, create, or delete branches
checkout  Checkout a branch or paths to the working tree
...
```

Detaljna pomoÄ‡ za komandu se dobija sa:

```
$ git help <ime komande>
```
 
---

## Konfiguracija

- Konfiguracija se Äuva u tekstualnim fajlovima koji imaju strukturu *.ini
  fajlova*.
- PreporuÄivo je parametre podeÅ¡avati putem <em>git config</em> komande.
- Tri nivoa konfiguracije:
  - *sistemska* (za sve korisnike instalacije) - fajl `/etc/gitconfig`
  - *po korisniku* (vaÅ¾i za ulogovanog korisnika) - fajl `~/.gitconfig` (POSIX)
      ili `C:\Documents and Settings\$USER\.gitconfig` (Windows)
  - *po repozitorijumu* (vaÅ¾i za tekuÄ‡i repozitorijum) - fajl `.git/config`
    unutar repozitorijuma
  
---

## Osnovna konfiguracija

.medium[
Konfigurisanje imena i email-a:

```
$ git config --global user.name "Igor DejanoviÄ‡"
$ git config --global user.email "igor DOT dejanovic AT gmail DOT com"
```

Konfiguracija se moÅ¾e izlistati sa:
```
$ git config --list
```

Editor za unos log poruka je postavljen na podrazumevani sistemski (najÄeÅ¡Ä‡e vi
ili vim). Windows korisnici uglavnom nisu viÄni upotrebi ovog editora.

Podrazumevani editor se na windowsu moÅ¾e promeniti na sledeÄ‡i naÄin:
```
# Windows - Obratiti paÅ¾nju na duple navodnike!!!
$ git config --global core.editor
    "'C:/Program Files/Windows NT/Accessories/wordpad.exe'"
          </code></pre>
```
]

---

## Konfiguracija za SSL i proxy

Za pristup serverima sa nevalidnim sertifikatom (npr. samopotpisan sertifikat)
potrebno je podesiti sledeÄ‡e za sertifikat koji smo preuzeli sa servera:

```
$ git config --global http.sslCAInfo /home/igor/config/all-certs.crt
```

ili ukoliko ne Å¾elimo proveru sertifikata:

```
$ git config --global http.sslVerify false
```

Ako je potreban pristup preko HTTP proxy-ja to se po korisniku moÅ¾e podesiti sa:

```
$ git config --global http.proxy 192.168.77.100:8080
```

---

## Povezivanje sa serverom upotrebom SSH kljuÄeva

            
- KljuÄevi se nalaze u `~/.ssh/` direktorijumu.
- GeneriÅ¡u se sa komandom:

```
$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]
Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
Your identification has been saved in /Users/you/.ssh/id_rsa.
Your public key has been saved in /Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
```

.footer[
  [GitHub: Generating SSH keys](https://help.github.com/articles/generating-ssh-keys/)
]

---

## Konfigurisanje diff/merge alata

```
$ git config --global merge.tool meld
```

Ili na windows-u:

```
$ git config --global merge.tool "'C:\ Program Files\...'"
```

---

## Konfiguracija veliÄine slova u nazivima fajlova

Unix fajl sistemi su uglavnom *case-sensitive* dok kod *windows*-a to
nije sluÄaj. Stoga je na unix file sistemima sasvim legalno da
postoje dva fajla istog naziva ali razliÄite veliÄine slova (na primer
`File1.txt` i `file1.txt`). Ovo na *windows*-u nije moguÄ‡e pa je dobro,
ukoliko Älanovi tima rade na razliÄitim operativnim sistemima,
podesiti sledeÄ‡e:

```
$ git config --global core.ignorecase true
```

Na taj naÄin Ä‡e git tretirati fajlove razliÄitog *case*-a kao identiÄne i
ukoliko se kreira fajl istog naziva kao postojeÄ‡i u repozitorijum ali
razliÄitog *case*-a on Ä‡e biti ignorisan.

---

## Konfiguracija zavrÅ¡etaka linija (<i>line endings</i>)

.medium[
Unix na kraju reda kod tekstualnih fajlova koristi LF bajt. Windows koristi dva
bajta - CR i LF. DanaÅ¡nji editori su u stanju da rade sa oba standarda. Git
podrÅ¾ava automatsku konverziju krajeva linija. TekuÄ‡a praksa je da se kreira
konfiguracioni fajl `.gitattributes` u korenskom folderu u kome se
"pomaÅ¾e" git-u da pravilno odredi tekstualne i binarne fajlove. Ovaj fajl se
*commit*-uje u repozitorijum tako da svi Älanovi tima imaju isto
podeÅ¡avanje. SadrÅ¾aj `.gitattributes` fajla:

```
  * text=auto
  *.png binary
  *.jpg binary
  *.exe binary
```
]
--
.message.is-warning[
.message-header[
Zadatak
]
.message-body[
**Napomena**: 
- Za dodatnu konfiguraciju pogledati konfiguracione parametre `core.eol`, `core.autocrlf` i `core.safecrlf`.]

]


---

## Normalizacija krajeva linija u repozitorijumu

Ako se u git repozitorijumu veÄ‡ nalaze fajlovi sa CRLF tada je potrebno izvrÅ¡iti
normalizaciju svih tekstualnih fajlova na LF
pratite
[uputstvo sa GitHub-a](https://help.github.com/articles/dealing-with-line-endings/).

---
name: operacije
layout: false
class: center, middle, inverse

# Osnovne operacije

---
layout: true

.section[[Operacije](#sadrzaj)]

---

## Inicijalizacija repozitorijuma

Repozitorijum je skup metapodataka koji se nalaze u skrivenom folderu .git
unutar korenskog foldera projekta.

Kreiranje se obavlja na sledeÄ‡i naÄin:

```
# Prelazak u folder gde se nalazi izvorni kod
# projekta
$ cd ~/Projekat
# Inicijalizacija
$ git init
Initialized empty Git repository in
/home/igor/Projekat/.git/
```

Ovim je kreiran prazan repozitorijum. SledeÄ‡i korak je dodavanje sadrÅ¾aja.

---

## Kloniranje repozitorijuma

Repozitorijum moÅ¾emo kreirati kloniranjem udaljenog
repozitorijuma.

```
$ git clone https://puppet.ftn.uns.ac.rs/rks/tim1/git RKSProjekat
```

Ili na primer ako se podigne lokalni server sa `git daemon` (videti sekciju
*Razmena promena*)

```
$ git clone git://192.168.100.50/ mojProjekat
```

gde je 192.168... IP adresa raÄunara na kojem je daemon pokrenut

---

## Ignorisanje fajlova

Obavlja se putem fajla `.gitignore` koji se nalazi u korenskom
folderu projekta. SadrÅ¾aj je sledeÄ‡eg oblika:

```
  # Ovo je komentar.
  # IgnoriÅ¡emo sve privremene fajlove
  *.tmp
  *~
  *.class
  /docs/*.html
  # Ignorisemo sve .html fajlove u docs i poddirektorijumima
  /docs/**/*.html
  # Ali ne ignorisemo rucno pisanu dokumentaciju
  !/docs/manual/*.html
```

`.gitignore` fajl se moÅ¾e kreirati i u poddirektorijumima i u tom sluÄaju
vaÅ¾i samo za dati poddirektorijum.

---

## Status repozitorijuma

Status predstavlja informacije kao Å¡to su:
- Grana na kojoj se nalazi radno stablo.
- Koji fajlovi su novi, nisu ignorisani i nisu spremni za dodavanje.
- Koji fajlovi/sadrÅ¾aji su spremni za dodavanje.

---

## Status repozitorijuma

Na primer, za repo. koji ima lokalnih promena

```
$ git status
# On branch master
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
# (use "git checkout â€“ <file>..." to discard changes in working directory)
#
# modified: fajl2.txt
#
# Untracked files:
# (use "git add <file>..." to include in what will be committed)
#
# file1.txt
no changes added to commit (use "git add" and/or "git commit -a")
```

- Radno stablo je na grani master (osnovna grana u git repozitorijumu â€“ videti u
  nastavku).
- `fajl2.txt` je izmenjen ali nije pripremljen za dodavanje dok je `file1.txt`
  novi fajl koji se trenutno ne prati.

---

## Priprema index-a

Priprema sadrÅ¾aja za *commit* se obavlja operacijama `add`, `rm` i sl.
```
# Dodavanje sadrÅ¾aja
$ git add MojaKlasa.java
$ git add .
# Interaktivno dodavanje sadrÅ¾aja
$ git add -p .
# Dodavanje/uklanjanje svih novih/modifikovanih/obrisanih fajlo
$ git add -A .
# Uklanjanje iz radnog stabla i indeksa.
$ git rm MojaKlasa.java
# Uklanjanje iz indeksa uz brisanje iz repozitorijuma.
# Fajl ostaje u radnom stablu ali se viÅ¡e ne prati.
$ git rm --cached MojaKlasa.java
# Uklanjanje promena zabeleÅ¾enih u indeksu
$ git reset HEAD ili samo git reset
# Uklanjanje zabeleÅ¾enih promena nad fajlom iz indeksa
$ git reset HEAD <putanja do fajla>

```
Promene se beleÅ¾e u index-u.
 

---

## Napomena za inicijalni *commit*

Pri inicijalnom *commit*-u repozitorijum je prazan pa `HEAD`
pokazivaÄ ne postoji. Zbog toga nije moguÄ‡e poniÅ¡titi indeks
komandom `git reset HEAD` pa se u tom sluÄaju radi:

```
$ git rm â€“r --cached .
```

--
.message.is-warning[
.message-header[
**Napomena**
]
.message-body[
- Ovo se radi samo kod inicijalnog *commit*-a. Nemojte ovo raditi kasnije! 
- Ova komanda registruje promenu koja Ä‡e obrisati sve fajlove (rekurzivno â€“ flag â€“r) u sledeÄ‡oj verziji.
]
]

---

## Odustajanje od praÄ‡enja fajla

.medium[
- U komandama tipa `git add -A` i `git commit -a` git automatski dodaje promene
  za fajlove koji se prate.
- Ukoliko je potrebno odustati od praÄ‡enja fajla a zadrÅ¾ati fajl u radnom stablu
  to se moÅ¾e uraditi na sledeÄ‡i naÄin:

  ```
  $ git rm --cached MojaKlasa.java
  ```

  Problem sa ovim pristupom je Å¡to Ä‡e fajl biti obrisan u
  udaljenom repozitorijumu.

- Ukoliko Å¾elimo da se fajl ne prati ali da ostane u svim
  repozitorijumima potrebno ga je obeleÅ¾iti kao takvog sa:

  ```
  $ git update-index --assume-unchanged MojaKlasa.java
  ```

  Kada Å¾elimo opet da pratimo fajl radimo:

  ```
  $ git update-index --no-assume-unchanged MojaKlasa.java
  ```
]

---

## Trajno beleÅ¾enje - *commit*

- Promena se trajno beleÅ¾i sa:

  ```
  $ git commit
  ```

  Potrebno je zatim uneti log poruku. Preporuka je da se u
  prvom redu unese skraÄ‡ena verzija, ostavi prazan red, a zatim
  unese duÅ¾a verzija poruke.

- Ukoliko indeks nije pripremljen moÅ¾e se koristiti preÄica:

  ```
  $ git commit -a
  ```

  Koja pre commit-a smeÅ¡ta u indeks sve modifikovane/obrisane
  fajlove. Novi fajlovi ne ulaze u indeks.

---

## Pregled istorije

- Istorija se moÅ¾e pregledati sa komandom:

  ```
  $ git log
  ```

- GrafiÄki pregled istorije se dobija sa

  ```
  $ gitk
  ```

  za tekuÄ‡u granu, ili
  
  ```
  $ gitk --all
  ```
  za sve grane.

---

## PremeÅ¡tanje fajlova, promena imena

PremeÅ¡tanje fajlova i promena imena moÅ¾e da se obavi na
sledeÄ‡i naÄin
  
```
$ git mv staroime novoime
```

ali poÅ¡to git ne vodi informacije o premeÅ¡tanjima i promenama
imena fajlova veÄ‡ koristi heuristiku koja to obavlja
post-festum, moÅ¾emo koristiti i alate operativnog sistema za
premeÅ¡tanje i promene imena, a zatim sve promene dodati sa

```
$ git add -A
```

Git Ä‡e detektovati premeÅ¡tene fajlove Äak i u sluÄaju da su
usput u izvesnoj meri promenjenog sadrÅ¾aja.

---

## Privremeno â€œsklanjanjeâ€ lokalnih izmena

- U sred ste rada i stiÅ¾e zahtev da se neÅ¡to mora hitno uraditi.
- Dva naÄina na koji se moÅ¾e odgovoriti na ovaj zahtev:
  - Napraviti novi klon repozitorijuma, postaviti se na odgovarajuÄ‡u granu,
    obaviti izmenu i poslati izmene.
  - Iskoristiti operaciju `stash` koja â€œsklanjaâ€ lokalne promene na stek promena
    i dovodi radno stablo u Äisto stanje, pozicioniranje na odgovarajuÄ‡u granu,
    obavljanje izmena, vraÄ‡anje lokalnih promena sa stash steka.

  ```
  $ git stash # Sklanjanje lokalnih promena
  $ git checkout neka_grana
  $ ... # Potrebne ispravke
  $ git commit -a
  $ git checkout ...
  $ git stash pop # VraÄ‡anje lokalnih promena
  ```
           
---

## Revizije

.medium[
- Revizije imenuju *commit* objekat.
- *Commit* moÅ¾e biti identifikovan sa kriptografskim SHA1 kljuÄem duÅ¾ine
  40-bajtova. Na primer `dae86e1950b1277e545cee180551750029cfe735`. MoÅ¾e
- se koristiti skraÄ‡ena verija ukoliko je jednoznaÄana, na primer `dae86e`.
  KoriÅ¡Ä‡enje simboliÄkih imena grana i oznaka (ili reference). Na primer,
  `master`, `heads/master`, `refs/heads/master`, `refs/remotes/origin/master`,
  `HEAD`, `ORIG_HEAD` itd.
- Referenca sa sufiksom `@` i vremenskom odrednicom u zagradama. Na primer,
  `HEAD@{yesterday}`, `master@{1 week ago}`, `moja_grana@{2011-03-17 17:00:00}`.
- Referenca sa sufiksom `@` i celim brojem `n` u zagradama oznaÄava vrednost
  reference `n` promena unazad. Na primer, `master@{3}`, `moja_grana@{1}`. Ako
  se referenca izostavi uzima se tekuÄ‡a grana.
- Revizija praÄ‡ena znakom `^` iza koje je opciono naveden ceo broj `n`. OznaÄava
  n-ti roditeljski commit date revizije. Na primer `HEAD^`, `master^^`,
  `v1.5.1^2`. Ako se n izostavi podrazumeva se 1.
- Revizija praÄ‡ena znakom `~` iza koje je opciono naveden ceo broj `n`. OznaÄava n-ti
  predak do koga se stiÅ¾e preko prvog roditelja. Na primer `master~`.
  Za detalje videti http://schacon.github.com/git/gitrevisions.html
]

---
name: grane
layout: false
class: center, middle, inverse

# Grane (*Branches*)

---
layout: true

.section[[Grane](#sadrzaj)]

---

## Grane â€“ Branches

- Grane su alternativni tokovi razvoja.
- Kreiranje grana kod Git-a je jednostavno i brzo tako da se ohrabruje njihovo
  Äesto kreiranje (npr. za svaki *feature*, *bugfix* i sl.).
- Osnovna grana se naziva *master*. Ona obiÄno uvek postoji (osim kod praznog
  repozitorijuma).
  
---

## Vrste grana

- Grane u git repozitorijumu mogu biti:
  - **lokalne**: Nastale u lokalnom repozitorijumu i ne prate druge grane.
  - **tracking**: Lokalne grane koje prate druge grane (tj. podeÅ¡ena ima je
    *upstream* grana). NajÄeÅ¡Ä‡e prate *remote tracking grane*.
  - **remote tracking**: Grane nastale u udaljenom repozitorijumu koje se
    kloniraju u lokalni.
    
---

## Kako to sve izgleda u repozitorijumu

.center[
![:scale 70%](git/DAG.svg)
]

.small[
- grane su reference(*refs*) na poslednji *commit* alternativnog toka.
- `nova_grana` je lokalna grana na kojoj se radno stablo trenutno nalazi (`HEAD`
  pokazuje na ovu granu).
- `origin/master` i `origin/udaljena_grana` su *remote tracking* grane udaljenog
  repozitorijuma `origin`.
- `master` je lokalna grana koja prati `origin/master` tj. ona je *tracking* grana.
]

---

## Grane i operacije

![Grane i operacije](git/branches-SO.png)

.footer[
   http://stackoverflow.com/questions/25786808/how-many-types-of-branches-exist-in-git
]

---

## Kreiranje grane

Kreiranje nezavisne lokalne grane
```
$ git branch mojagrana 
```

Kreiranje grane koja prati udaljenu (*tracking branch*) Udaljena grana je u
lokalnom repozitorijumu predstavljena kao `<udaljeni repo>/<ime grane>`. Na
primer `origin/udaljenagrana`.
```
$ git branch -t origin/udaljenagrana
```

Prethodni primer Ä‡e kreirati tracking granu koja se zove kao i udaljena
(`udaljenagrana`). Ako Å¾elimo da kreiramo tracking granu koja se zove drugaÄije
radimo:

```
$ git branch mojagrana -t origin/udaljenagrana
```

---

## Informacije o granama

Spisak lokalnih grana, sa `*` oznaÄena tekuÄ‡a
```
$ git branch
  * master
  moja_grana
```

Spisak lokalnih i *remote tracking* grana
```
$ git branch -a 
```

Spisak *remote tracking* grana
```
$ git branch -r
```

Spisak lokalnih grana i njihovih *upstream* grana
```
$ git branch -vv
```

---

## Prelazak izmeÄ‘u grana

.medium[
- Promena grane podrazumeva izmenu radnog stabla tako da
  odgovara verziji sa grane.
- Grana se menja komandom checkout na sledeÄ‡i naÄin:
  ```
  $ git checkout moja_grana
  Switched to branch â€™moja_granaâ€™
  $ git checkout master
  Switched to branch â€™masterâ€™
  ```

- Ako Å¾elimo da kreiramo novu granu i preÄ‘emo na nju:
  ```
  $ git checkout -b moja_grana
  Switched to a new branch â€™moja_granaâ€™
  ```

- A ako je novokreirana grana *tracking*:
  ```
  $ git checkout -t origin/udaljena_grana
  # Ili ako Å¾elimo posebno ime
  $ git checkout -b moja_grana -t origin/udaljena_grana
  ```
]

---

## Brisanje lokalnih grana

Brisanje lokalne grane:
```
$ git branch -d grana_za_brisanje
```

Prethodna komanda Ä‡e proveriti da li je grana prethodno spojena (*merge*) na
neku drugu i ako nije odbiti da uradi posao jer bi to znaÄilo ostavljanje
nespojenih *commit*-a sa grane da "vise" (*dangling objects*). Ovi *commit*-i bi
bili trajno obrisani prilikom sledeÄ‡eg izvrÅ¡avanja komande `git gc`.

Ako smo sigurni da Å¾elimo da obriÅ¡emo nespojenu granu to radimo sa:
```
$ git branch -D grana_za_brisanje
```

---

## Slanje promena u drugi repozitorijum

.medium[
Slanje promena na *upstream* granu se radi sa:

```
$ git push
```

Objavljivanje/kreiranje grane na udaljenom repozitorijumu se radi na sledeÄ‡i
naÄin:
```
$ git push origin moja_grana
$ git push -u origin moja_grana    # sa podeÅ¡avanjem upstream grane
```

Ili ako Å¾elite da se na udaljenom repo-u zove drugaÄije
```
$ git push origin moja_grana:super_grana
```

Ili ako Å¾elite da poÅ¡aljete sve grane (npr. *push* u prazan repo)
```
$ git push --all origin # ili...
$ git push origin '*:*'
```
]

---

## Slanje promena u drugi repozitorijum

.medium[
A ako Å¾elimo da lokalne grane ujedno postanu tracking za
upravo objavljene grane
```
$ git push -u --all origin
```

Naravno preduslov je da je `origin` udaljeni repozitorijum
podeÅ¡en.
]

---

## push.default - TODO

---

## PodeÅ¡avanje veze sa udaljenim repozitorijumom

.medium[
Prethodne komande su podrazumevale da je udaljeni repozitorijum sa imenom `origin`
veÄ‡ podeÅ¡en. Ukoliko je lokalni repozitorijum nastao kloniranjem udaljenog ovo
jeste tako, ali ukoliko nije (na primer, hoÄ‡emo da uradimo `push` u prazan
centralni repozitorijum) moÅ¾emo kreirati vezu na
sledeÄ‡i naÄin:

```
$ git remote add origin https://puppet.ftn.uns.ac.rs/rks/timX/git
```

A zatim se mogu izlistati svi udaljeni repozitorijumi sa:
```
$ git remote
```

Ili se mogu prikazati detalji odreÄ‘enog repozitorijuma, zajedno sa granama koje
se prate sa
```
$ git remote show origin
```
]

---

## Brisanje udaljenih grana

Brisanje grane u udaljenom repozitorijumu se moÅ¾e uraditi na sledeÄ‡i naÄin:

```
$ git push origin :udaljena_grana
```

ili u novijim verzijama:
```
$ git push origin --delete udaljena_grana
```

---

## PoreÄ‘enje grana (*commit*-a)

.medium[
Da bi videli koji fajlovi su promenjeni izmeÄ‘u dve grane uz ignorisanje
*whitespace* karaktera (`-w`):

```
$ git diff -w --name-status master..integration
```

Da vidimo promene izmeÄ‘u vrhova dve grane:

```
$ git diff master..integration | kompare -
```

Da vidimo vizuelno sve izmene nad fajlovima u folderu `src`:

```
$ git diff -w --diff-filter=M master..integration src/ | kompare -
```

Å ta imamo na `integration` Å¡to nije ukljuÄeno na `master` (**tri taÄke!**):
```
$ git diff master...integration | kompare -
```

PoreÄ‘enje moÅ¾emo obaviti izmeÄ‘u bilo koja dva *commit*-a (po *hash* *id*-u).
]

---
name: merging
layout: false
class: center, middle, inverse

# Spajanje grana (*merging*)

---
layout: true

.section[[Spajanje](#sadrzaj)]

---

## Spajanje grana â€“ *merge*

- Komanda `pull` automatski radi spajanje grane sa udaljenog repozitorijuma.
  ```
  $ git pull
  ```

- A moÅ¾emo spajanje obaviti i eksplicitno. Na primer:
  ```
  $ git fetch
  $ git merge origin/master
  ```
- `fetch` Ä‡e pokupiti promene sa udaljenog repozitorijuma ali neÄ‡e automatski
  obaviti spajanje na tekuÄ‡u *tracking granu*.
- `merge` obavlja spajanje. Ako ne doÄ‘e do konflikta automatski se vrÅ¡i `commit`
  (ovo se moÅ¾e promeniti navoÄ‘enjem `--noâ€“commit` parametra).
- Ako doÄ‘e do konflikta potrebno ga je razreÅ¡iti ruÄno i zatim dodati promenu i
  uraditi `commit`.
  
---

## Spajanje grana â€“ strategije

- Prilikom operacije spajanja moguÄ‡e je zadati odgovarajuÄ‡u `merge` strategiju
  navoÄ‘enjem parametra iza `-X`.
- Podrazumevana strategija je trenutno `recursive` a interesantne su i strategije
  `ours/theirs` koje Ä‡e preuzeti naÅ¡e ili udaljene promene kao podrazumevane u
  novoj verziji.

---

## Spajanje grana â€“ *fast-forward merge*

Ukoliko je polazni commit grane koju spajamo jednak vrhu tekuÄ‡e grane git Ä‡e
podrazumevano da uradi tzv. *fast-forward* merge.

.center[
![:scale 85%](git/Merge-ff.svg)
]

---

## Spajanje grana â€“ *no fast-forward merge*

Ukoliko se Å¾eli zadrÅ¾ati informacija o tome da je postojao alternativni tok
(grana) moÅ¾e se proslediti parametar `--no-ff` Äime se merge obavlja na klasiÄan
naÄin.

.center[
![:scale 85%](git/Merge-no-ff.svg)
]

---

## Spajanje grana â€“ *rebase*

Drugi mehanizam spajanja promena sa druge grane je *rebase*.

![:scale 80%](git/Merge-rebase.svg)

--

.message.is-danger[
.message-header[
VaÅ¾no
]
.message-body[
- `rebase` menja istoriju. Ne raditi na udaljenim deljenim granama.
]
]

---

## Preuzimanje pojedinaÄnih *commit*-a â€“ *cherry-pick*

.medium[

Ukoliko je potrebno preuzeti pojedinaÄnu promenu (*commit*) i primeniti je na
tekuÄ‡u granu koristi se komanda `cherry-pick`.

Primeri:

- Preuzmi commit master na tekuÄ‡i `HEAD`
  ```
  $ git cherry-pick master
  ```
  
- Preuzmi *commit master* ali edituj *commit* log poruku 
  ```
  $ git cherry-pick -e master
  ```
- Preuzmi *commit* 7f... u WT i index
  ```
  $ git cherry-pick -n 7f546d
  ```
- Preuzmi 5-ti i treÄ‡i *commit* od kraja *master* grane
  ```
  $ git cherry-pick master~4 master~2 
  ```
]

---

## RazreÅ¡avanje konflikta

- Konflikti Ä‡e biti oznaÄeni odgovarajuÄ‡im markerima unutar tekstualnih fajlova.
  ```
  <<<<<<< HEAD:file.txt
  Hello world
  =======
  Goodbye
  >>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:file.txt
  ```

- Konflikt razreÅ¡avamo ruÄnom ispravkom fajla u kome je nastao i dodavanjem u indeks:
  ```
  $ git add file.txt
  $ git commit
  ```
  
---

## RazreÅ¡avanje konflikta

- Kod konflikta komanda git diff Ä‡e prikazivati *three-way-diff* izmeÄ‘u zajedniÄkog
  pretka, tekuÄ‡e verzije i verzije sa druge grane. RazreÅ¡enje preuzimanjem naÅ¡e ili
  tuÄ‘e verzije obavljamo sa:
  ```
  $ git checkout --ours file.txt
  $ git checkout --theirs file.txt
  ```
  posle Äega je potrebno uraditi `add`

- Od spoja moÅ¾emo odustati sa:
  ```
  $ git master --abort
  ```

---
name: razmena
layout: false
class: center, middle, inverse

# Razmena promena

---
layout: true

.section[[Razmena](#sadrzaj)]

---

## Razmena promena

- MoÅ¾e se obavljati putem deljenog repozitorijuma:
  ```
  $ git pull ....
  $ git fetch ....
  $ git push ....
  ```

- Putem lokalnog daemon-a:
  ```
  $ git daemon --export-all --base-path=.
  ```

  Ili ako Å¾elimo i moguÄ‡nost `push` operacije
  ```
  $ git daemon --export-all --enable=receive-pack --base-path=.
  ```

  **Napomena:** Sa ovom komandom `push` operacija nije moguÄ‡a
  ka repozitorijumima koji nisu *bare*.

---

## Razmena promena

Ili upotrebom fajlova (mejlom, na prenosnom disku i sl.).

- Putem tzv. *bundle*-ova :
  ```
  $ git bundle ...
  $ git unbundle ....
  ```
  
---

## Razmena promena

- Putem zakrpa (*patches*). U ovoj varijanti promena moÅ¾e da se prenosi izmeÄ‘u repozitorijuma sa razliÄitom istorijom.

  Poslednjih n *commit*-a
  ```
  $ git format-patch -n 
  ```
  
  Promene na `master` grani
  ```
  $ git format-patch origin/master..master
  ```

  Od poslednjeg `pull`-a i zatim primena na odrediÅ¡ni repozitorijum
  ```
  $ git am *.patch
  ```

---
name: greske
layout: false
class: center, middle, inverse

# Ispravke greÅ¡aka

---
layout: true

.section[[Ispravke](#sadrzaj)]

---

## Ispravke greÅ¡aka

Imamo sledeÄ‡e situacije:

- Uradili smo lokalne izmene ili smo izmenili indeks i Å¾elimo od tih promena da
  odustanemo.
- Uradili smo izmenu i primetili smo da smo pogreÅ¡ili a izmenu joÅ¡ nismo poslali
  u udaljeni repozitorijum.
- Primetili smo da je izmena koja nije poslednja a poslata je u udaljeni
  repozitorijum neispravana.
- Izmena koja nije poslednja je neispravna ali joÅ¡ uvek nije poslata u udaljeni
  repozitorijum.

--

.message.is-danger[
.message-header[
**VaÅ¾na napomena**
]
.message-body[
- Obratite paÅ¾nju da se istorija koja je objavljena (promene poslate u udaljeni repozitorijum) ne sme menjati! 
- MoÅ¾e se samo kreirati nova promena koja poniÅ¡tava staru.
]
]

---

## Odustajanje od lokalnih promena

Izmenili smo indeks ili smo izmenili fajlove u lokalnom stablu. Ukoliko Å¾elimo
da poniÅ¡timo sadrÅ¾aj index-a i/ili lokalnog stabla koristimo komandu `reset`.
`reset` komanda moÅ¾e da, opciono, "premota" `HEAD` pokazivaÄ tekuÄ‡e grane na
zadatu verziju i da uskladi index i/ili radno stablo sa datom verzijom.

DovoÄ‘enje index-a i radnog stabla na `HEAD` verziju.
Posle ovoga `git diff [--cached]` komanda javlja da
nema razlika.
```
$ git reset --hard HEAD
```

---

## Odustajanje od lokalnih promena

Samo Å¾elimo da premotamo tekuÄ‡i `HEAD` jednu verziju unazad ali ne Å¾elimo da
promenimo indeks i radno stablo. Promene obeleÅ¾ene za dodavanje ostaju.

```
$ git reset --soft HEAD^
```

Resetujemo indeks ali ne i radno stablo. Ovo je podrazumevano
ponaÅ¡anje (`--mixed` moÅ¾e da se izostavi).
```
$ git reset --mixed HEAD
```

--

.message.is-danger[
.message-header[
**Napomena**
]
.message-body[
- Pomeranjem `HEAD`-a git pamti prethodni u `ORIG_HEAD` tako da moÅ¾emo uvek da poniÅ¡timo efekat `reset` komande.
]
]

---

## PoniÅ¡tavanje lokalne promene nad proizvoljnim fajlom

Ukoliko Å¾elimo da odustanemo od promene proizvoljnog fajla radimo sledeÄ‡e:

- VraÄ‡anje na verziju iz indeksa
  ```
  $ git checkout -- readme.txt
  ```

- VraÄ‡anje na verziju sa `HEAD`-a
  ```
  $ git checkout HEAD readme.txt
  ```
  
---

## Izmena poslednjeg *commit*-a

Ukoliko smo uradili commit a zatim primetili da smo neÅ¡to zaboravili, ili smo
upisali pogreÅ¡nu log poruku moÅ¾emo uraditi sledeÄ‡e:

```
# Ovaj commit je pogreÅ¡an
$ git commit 
# VrÅ¡imo potrebne dorade
# KaÅ¾emo git-u da je ovo dodatak
$ git commit --amend 
# DobiÄ‡emo moguÄ‡nost aÅ¾uriranja log poruke
# ...Å¡to je vrlo sliÄno sa sledeÄ‡im:
# Premotavamo se na verziju unazad
$ git reset --soft HEAD^
# ali indeks i radno stablo ne menjamo
# ... obavljamo izmene ...
# radimo commit sa log porukom prethodnog HEAD-
$ git commit -c ORIG_HEAD
# DobiÄ‡emo moguÄ‡nost da modifikujemo log poruku
```

---

## PoniÅ¡tavanje proizvoljne promene

Ukoliko Å¾elimo da poniÅ¡timo efekat neke od promena iz istorije koristimo komandu
revert:

```
$ git revert <verzija>
# ... razreÅ¡avamo eventualne konflikte
# izazvane kasnijim izmenama ...
$ git commit
```

---

## Izmena istorije

.message.is-danger[
.message-header[
**Napomena**
]
.message-body[
- Ovo se radi samo sa lokalnim granama, izmenama na tracking granama koje joÅ¡ nisu poslate na udaljeni repozitorijum, ili u dogovoru sa ostatkom tima!!!
]
]

.medium[

Proizvoljne commit-e moÅ¾emo menjati sa rebase komandom u interaktivnom modu.

```
$ git rebase -i HEAD~3
# Zadajemo parent commit-a od kojeg kreÄ‡emo
# Dobijamo listu u editoru sliÄnu ovoj
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
# Rebase da5fd63..2bb69f5 onto da5fd63
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like "squash", but discard this commitâ€™s log message
# x, exec = run command (the rest of the line) using shell
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#
```
]

---

## Izmena istorije

Menjamo `pick` komande sa `edit` i `squash`. Na primer:

```
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Ovim Ä‡emo dobiti moguÄ‡nost izmene *commit*-a `f7f3f6d`.
Radimo izmenu i modifikujemo commit sa `--amend` opcijom.
Zatim nastavljamo `rebase` sa:

```
$ git rebase â€“â€“continue
```

---
## Izmena istorije sa *git rebase --onto*

Ukoliko Å¾elimo da deo grane preselimo na drugu granu koristimo
*git rebase --onto*.

Dva oblika:

```
git rebase --onto new_base old_base
```

```
git rebase --onto new_base old_base target_ref
```

---

## Potraga za izgubljenim *commit*-ima â€“ *reflog*

- `reflog` predstavlja strukturu koja sadrÅ¾i istoriju izmena `HEAD` reference.
- Podrazumevano ova struktura "pamti" 30 dana unazad.

  ```
  git reflog
  ```

.center[
![:scale 60%](git/reflog.png)
]

---
name: odrzavanje
layout: false
class: center, middle, inverse

# OdrÅ¾avanje repozitorijuma

---
layout: true

.section[[OdrÅ¾avanje](#sadrzaj)]

---

## OdrÅ¾avanje repozitorijuma

- Git ima jednostavne mehanizme skladiÅ¡tenja istorije bazirane na *snap-shot*
  modelu. ÄŒuvaju se celi fajlovi u obliku *BLOB* objekata.
- Inicijalno se *BLOB*-ovi Äuvaju kao zasebni fajlovi u `.git/objects` folderu.
- Zbog toga, posebno kod velikih fajlova, repozitorijum moÅ¾e vremenom da
  znaÄajno poraste. U ovim situacijama Git omoguÄ‡ava â€œpakovanjeâ€ objekata
  upotrebom efikasnog delta algoritma. Pronalaze se sliÄni BLOB-ovi izmeÄ‘u kojih
  se izraÄuvana razlika (delta).
- Da bi se obavilo pakovanje objekata, i uklanjanje "viseÄ‡ih" objekata (*dangling
  objects*), dovoljno je pozvati:
  ```
  $ git gc
  ```
  
.footer[
  Detalje moÅ¾ete naÄ‡i na
  http://schacon.github.com/git/user-manual.html#pack-files
]

---
name: modeli
layout: false
class: center, middle, inverse

# Modeli grananja

---
layout: true

.section[[Modeli](#sadrzaj)]

---

## Modeli grananja (*branching models*)

- Konvenciju imenovanja grana i proces koji opisuje naÄin njihovog koriÅ¡Ä‡enja.
- Trivijalan model grananja koristi samo `master` granu.
- NeÅ¡to sloÅ¾eniji koristi granu za razvoj (`develop`) i `master` granu na koju se
  vrÅ¡i spajanje kada procenimo da imamo stabilnu verziju.
- Kod razvoja sloÅ¾enog softvera gde imamo viÅ¡e verzija koje moramo odrÅ¾avati
  potreban je i neÅ¡to sloÅ¾eniji model.
- Jedan od najpopularnijih modela grananja se naziva `GitFlow`.ref[1].

.footer[
   1. http://nvie.com/posts/a-successful-git-branching-model/
]

---

## *Feature branches*

- NaÄin razvoja softvera gde se za svaku funkcionalnost softvera (*feature*)
  kreira nova grana.
- Prednosti:
  - izolacija koda za odreÄ‘enu funkcionalnost,
  - loÅ¡e implementirana funkcionalnost se lako poniÅ¡tava,
  - jednostavniji uvid u progres po funkcionalnostima.
- Mane:
  - kod funkcionanosti koja se dugo razvija odlaÅ¾e se integracija Å¡to moÅ¾e
    dovesti do kasnijih problema.

---

## *GitFlow* model

![GitFlow](git/GitFlow.svg)

.footer[
  http://nvie.com/posts/a-successful-git-branching-model/
]

---

## Modifikovani *GitFlow* model

![GitFlow reloaded](git/GitFlow-Reloaded.svg)

---
name: praksa
layout: false
class: center, middle, inverse

# PreporuÄena praksa

---
layout: true

.section[[Praksa](#sadrzaj)]

---

## PreporuÄena praksa u radu sa granama

- ÄŒest `commit` vs. Äista istorija
- Lokalne (privatne) grane - Äest *commit* za beleÅ¾enje meÄ‘uverzija (moguÄ‡nost
  *undo*-a).
- Kasnije spajanje na javnu granu (npr. `master` ili `develop`) uz integraciju
  *commit*-a (*squash*).

.footer[
  [Benjamin Sandofsky, Understanding the Git Workflow](http://sandofsky.com/blog/git-workflow.html)
]

---

## Kratkotrajne grane

Kreiramo i prelazimo na novu granu:
```
$ git checkout -b private_feature_branch
```

VrÅ¡imo izmene, aÅ¾uriramo indeks:
```
$ git add ...
```

BeleÅ¾imo promenu:
```
$ git commit -am "WIP"
```

.footer[
  [Benjamin Sandofsky, Understanding the Git Workflow](http://sandofsky.com/blog/git-workflow.html)
]

---

## Kratkotrajne grane

Kada zavrÅ¡imo sa izmenama, prelazimo na master granu:
```
$ git checkout master
```

Spajamo granu uz integraciju svih *commit*-a
```
$ git merge --squash private_feature_branch
```

`Commit` - zadajemo detaljnu log poruku:
```
$ git commit -v
```

.footer[
  [Benjamin Sandofsky, Understanding the Git Workflow](http://sandofsky.com/blog/git-workflow.html)
]

---

## Dugotrajne grane

.medium[

Kada jedan *squash commit* ne bi bio adekvatan jer se grana duÅ¾e razvijala pa je
potrebno svesti na viÅ¡e *commit*-a. Na *feature* grani radimo sreÄ‘ivanje
interaktivnim *rebase*-om
```
$ git rebase --interactive master
```

ili kreiramo granu za sreÄ‘ivanje promena:
```
# Prelazimo na master
$ git checkout master
# Kreiramo granu za sreÄ‘ivanje sa mastera
$ git checkout -b cleaned_up_branch
# Spajamo i integriÅ¡emo sve promene sa privatne grane
$ git merge --squash private_feature_branch
# Resetujemo indeks da bi dobili Äistu situaciju
# sa svim izmenama koje su bile na privatnoj grani u radnoj kopiji.
$ git reset
```

Posle ovoga moÅ¾emo obaviti standardno interaktivno aÅ¾uriranje indeksa i
*commit*-e.

]

.footer[
  [Benjamin Sandofsky, Understanding the Git Workflow](http://sandofsky.com/blog/git-workflow.html)
]

---

## Upotreba *Subversion* repozitorijuma

Git je moguÄ‡e koristiti i sa *Subversion* repozitorijumom.

```
# Kloniranje svn repozitorijuma standardnog layout-a (trunk, branches, tags)
$ git svn clone -s https://..../
# Izmena fajlova + commit (moÅ¾e viÅ¡e puta)
# Preuzimanje promena sa svn-a i rebase lokalnih promena
$ git svn rebase
# Slanje izmena na svn repo
$ git svn dcommit
```

---

## *Subversion* i lokalne grane

MoguÄ‡e je kreirati i grane na svn repozitorijumu i povezati ih sa
lokalnim

```
$ git checkout -b mojagrana
# Izmene fajlova
$ git commit -m "Neka izmena"
# Kreiranje grane na svn-u (mora se biti online, radi se samo jednom)
$ git svn branch mojagrana
# Povezivanje lokalne i svn grane (radi se samo jednom)
$ git branch --set-upstream mojagrana remotes/mojagrana
# Slanje promena
$ git svn dcommit
```

---
name: implementacija
class: center, middle, inverse
layout: false

# Implementacija

---
layout: true

.section[[Implementacija](#sadrzaj)]

---

## Git repozitorijum

- **Objektna baza**: Jednostavan model repozitorijuma baziran na mapama (parovi
  kljuÄ-vrednost).
- KljuÄevi su **SHA1 heÅ¡ sadrÅ¾aja** koji se Äuva + hedera.
- **Tri vrste objekata/vrednosti**. SadrÅ¾aj se komprimuje pomoÄ‡u *zlib* biblioteke.
- Reference - *pokazivaÄi* na odreÄ‘ene objekte u repozitorijumu.
- Repozitorijum se nalazi u **.git** direktorijumu unutar direktorijuma gde je
    izvrÅ¡ena inicijalizacija sa `git init` komandom (videti u nastavku).

---

## Vrste git objekata

Repozitorijum je objektna baza gde postoje tri vrste objekata:

- **Blob:** Niz bajtova bez semantike. NajÄeÅ¡Ä‡e sluÅ¾i za opis sadrÅ¾aja fajla.
- **Stablo(Tree):** ÄŒuva niz referenci na blobove i druga podstabla zajedno sa
  meta-podacima kao Å¡to su: naziv fajla, mod i sl.
- **Commit:** "PokazivaÄ" na stablo koje opisuje kako je projekat izgledao u
  trenutku *commit*-a. Osim toga sadrÅ¾i niz meta-informacija kao Å¡to su autor,
  vreme nastanka, pokazivaÄe na prethodne *commit*-e i dr.

---

## Vrste git objekata

- Svi objekti su smeÅ¡teni na isti naÄin u `.git/objects` direktorijumu. Prva dva
  karaktera *SHA1* heÅ¡a Äine naziv poddirektorijuma dok preostalih 38 Äini ime
  fajla.
- Na primer:
  `.git/obects/bb/82d56602c51c7998911b2d07e84e25a942a028`
- Gotovo sve Git operacije se baziraju na manipulaciji sa strukturom koja se
  sastoji od objekata Äiji tip je jedan od navedenih.
  
---

## BLOB

Niz bajtova bez semantike i metapodataka. NajÄeÅ¡Ä‡e sluÅ¾i za
opis sadrÅ¾aja fajla.

```java
blob 107\0
class MainClass {
  static void main(int argc, String[] argv) {
    System.out.println("Hello World!");
  }
}
```
.center[
![:scale 30%](git/blob.svg)
]

---

## *Tree*

- ÄŒuva niz referenci na blobove i druga podstabla zajedno sa meta-podacima kao
  Å¡to su: naziv fajla, mod i sl.
- Rekurzivne reference na druga stabla.
- Struktura tree objekta:

  ```
  tree 64\0
  100644 blob 8e0462460e55357686a844cfd27564ab5a6055a6 README
  040000 tree 1d6a41c11d3557faae7522bc2af7042e8723e63a src
  ```
.center[
![:scale 30%](git/tree.svg)
]

---

## *Commit*

- SadrÅ¾i informacije o trajnoj zabeleÅ¡ci (*commit*): referenca na stablo
  (*tree*), autor, osobu koja je kreirala zabeleÅ¡ku (*commiter*), datum i vreme
  nastanka kao i vezu prema pretodnim zbeleÅ¡kama.

Struktura commit objekta:
```
commit 195\0
tree c7984074ae6aae0bb8b087ca0a5bd6026b108528
author Igor Dejanovic <igor.dejanovic@gmail.com> 1350920069 +0200
committer Igor Dejanovic <igor.dejanovic@gmail.com> 1350920069 +0200
Prvi commit.
```
.center[
![:scale 20%](git/commit.svg)
]

---

## Prvi *commit*

.center[![:scale 35%](git/prvi-commit.svg)]

---

## Drugi *commit*

.center[![:scale 65%](git/drugi-commit.svg)]

---

## Reference

- PokazivaÄi na objekte u git repozitorijumu (najÄeÅ¡Ä‡e *commit*-e).
- SmeÅ¡tene u `.git/refs` direktorijumu.
- Dele se na:
  - **glave (heads)** koje predstavljaju pokazivaÄ na poslednji *commit* sa grane.
  - **oznake (tags)** koji predstavljaju obeleÅ¾ivaÄ/marker *commit*-a koji je, na
    neki naÄin, poseban. Na primer, moÅ¾emo oznaÄiti odreÄ‘enu verziju projekta.
- Specijalna referenca `HEAD` pokazuje na glavu koja je tekuÄ‡a Äime oznaÄava granu
  na kojoj se radna kopija trenutno nalazi. SmeÅ¡tena je u `.git/HEAD` fajlu.
- Navode se prema putanji u `refs` folderu (npr. `refs/heads/master`).

---

## Git repozitorijum sa objektima i referencama

.center[![:scale 100%](git/git-repo.svg)]

---

## Literatura

- Scott Chacon, Ben Straub: *Pro Git*, Apress, 2014.
  Dostupna na: https://git-scm.com/book/en/v2
- Git dokumentacija - https://git-scm.com/doc

--

class: center, middle, theend, hide-text
layout: false
background-image: url(../theend.gif)

</textarea>
	<script src="../remark-latest.min.js"></script>
	<script>
		// https://github.com/gnab/remark/issues/72
		        remark.macros.scale = function (percentage) {
		            var url = this;
		            return '<div class="center"><img src="'
		                 + url + '" style="width: ' + percentage + '" /></div>';
		        };
		        var slideshow = remark.create({
		                    highlightLanguage: 'python',
		                    // highlightStyle: 'obsidian',
		                    highlightStyle: 'github',
		                    highlightLines: true,
		                    countIncrementalSlides: false,
		                    navigation: {
		                      // Enable or disable navigating using scroll
		                      // Default: true
		                      // Alternatives: false
		                      scroll: false,
		
		                      //click: true,
		                    }
		                });
	</script>
	<script src="../mermaid.min.js"></script>
	<script>
		mermaid.initialize({startOnLoad:true});
	</script></body>

</html>