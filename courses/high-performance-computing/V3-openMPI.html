<!DOCTYPE html>
<html>

<head>
	<title>[High-performance computing (HPC)](/courses/#table-of-contents)</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="../remarkslides.css">
	<!-- MathJax‚Ñ¢ -->
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
	</script>
	<!-- mermaid dijagram -->
	<link rel="stylesheet2" href="../mermaid.min.css">
	<script>
		mermaid.initialize({startOnLoad:true});
	</script>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127734928-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		      function gtag(){dataLayer.push(arguments);}
		      gtag('js', new Date());
		
		      gtag('config', 'UA-127734928-1');
	</script>
	<!-- google analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		      ga('create', 'UA-127734928-1', 'auto');
		      ga('send', 'pageview');
	</script>
</head>

<body>
	<textarea id="source">class: center, middle

## [High-performance computing (HPC)](/courses/#table-of-contents)
### V3-openMPI


.author[[dr. Milovan Toma≈°eviƒá](https://milovantomasevic.com/resume/)]

.small[[Fakulteta za informacijske ≈°tudije v Novem mestu (FI≈†)](https://www.fis.unm.si/en/)</br>![:scale 10%](../fis/fis.png) .small[ [üåê‚ûô milovan.tomasevic.fis.unm.si](http://milovan.tomasevic.fis.unm.si)</br> [üìß‚ûô milovan.tomasevic@fis.unm.si](mailto:milovan.tomasevic@fis.unm.si)]]



.created[08.03.2019 u 17:32]


---


name: sadrzaj

# Sadr≈æaj

- [MPI](#mpi)
- [Komunikatori](#komunikatori)
- [Point to Point komunikacija](#p2p)
- [Kolektivna komunikacija](#kk)

---
name: mpi
class: center, middle, inverse

# MPI

---
layout: true

.section[[MPI](#sadrzaj)]

---
## Message Passing Interface (MPI)

- Standard koji propisuje komunikaciju razmenom poruka na razliƒçitim paralelnim arhitekturama.
- **MPI 1.x** (1994.) podr≈°ka za C, C++, Fortran
- **MPI 2.x** (1997.) podr≈°ka za C, C++, Fortran
- **MPI 3.x** (2012.) podr≈°ka za C, Fortran
- Od formulisanja standarda razvijene su razliƒçite implementacije MPI (komercijalne i otvorenog koda).

---

## MPI ciljna arhitektura

![:scale 80%](img/mpi.png)

---

## Format OpenMPI programa

```c
#include "mpi.h"

	int main(int argc, char *argv[]) {
	MPI_Init(&argc, &argv);

	// MPI code	

	MPI_Finalize();

	return 0;
}
```

---

## Kompajliranje MPI programa
- Pozicionirati se u direktorijum u kojem se nalazi izvorni kod MPI programa i uneti:
```console
mpicc <izvorna_datoteka>
```
- `mpicc` je omotaƒçka skripta za `gcc`, pa se pri kompajliranju mogu navesti opcije gcc kompajlera.

- Pokretanje:
```console
mpiexec [-np <N>] <izvrsna_datoteka>
```
- `-np <N>` - opcija za zadavanje broja procesa koji ƒáe biti kreirani pri pokretanju programa.

---

## Primer 1: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`hello_world.c`</a>

.message.is-dark[
.message-header[
Primer
]
.message-body[
```c
#include <stdio.h>
#include "mpi.h"

int main(int argc, char *argv[]) {
	int size, rank;

	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	printf("Hello World iz %d/%d.\n", rank, size);
	
	MPI_Finalize();

	return 0;
}
```
]
]

---

## MPI osnovni koncepti

- Komunikator (eng. *communicator* )
- `Point to Point` komunikacija (eng. *Point-to-Point communication*)
- Kolektivna komunikacija (eng. *Collective communication*)

---
layout: false
name: komunikatori
class: center, middle, inverse

# Komunikatori

---
layout: true

.section[[Komunikatori](#sadrzaj)]

---

## Komunikatori

- Logiƒçki gledano, **komunikator** predstavlja grupu procesa unutar koje
svaki proces ima svoj **rank** (odnosno identifikator).

![:scale 80%](img/komunikator.png)

- `MPI_COMM_SELF, MPI_COMM_NULL`

---

## Komunikatori
- Tokom izvr≈°avanja MPI istovremeno mo≈æe da postoji vi≈°e komunikatora.

- `MPI_Comm` tip podatka.

- Funkcije za pravljenje komunikatora:

```c
# kreiranje novog komunikatora deljenjem postojeƒáeg
MPI_Comm_split(MPI_Comm comm, int color, int key, MPI_Comm* newcomm);

# novi komunikator je kopija postojeƒáeg
int MPI_Comm_dup(MPI_Comm comm, MPI_Comm *newcomm)

# i druge
```

---

## Zadatak 1: Komunikatori

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Napraviti OpenMPI C program koji kori≈°ƒáenjem funkcije `MPI_Comm_split` na osnovu podrazumevanog pravi dva nova komunikatora. Procese podeliti u dva komunikatora na osnovu parnosti ranka unutar `MPI_COMM_WORLD` komunikatora. Pri tom relativni poredak procesa unutar komunikatora treba da bude isti kao i u podrazumevanom komunikatoru. Svaki proces na standardni izlaz treba da ispi≈°e svoj rank unutar `MPI_COMM_WORLD` i novoformiranog komunikatora.
]
]

--
.message.is-dark[
.message-header[
Primer
]
.message-body[
- Primer ispisa za jedan proces:
```console
MPI_COMM_WORLD rank: 0/4 - ncomm rank: 0/2
```
]
]

--
.message.is-success[
.message-header[
Odgovor
]
.message-body[
- <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Re≈°enja/`communicators.c`</a>
]
]

---

## MPI tipovi podataka
- Zarad portabilnosti MPI standard defini≈°e tipove podataka.

.center-table.small[

|   MPI tip podatka  |    C tip podatka   |
|:------------------:|:------------------:|
|      MPI_CHAR      |     signed char    |
|      MPI_SHORT     |  signed short int  |
|       MPI_INT      |     signed int     |
|      MPI_LONG      |   signed long int  |
|  MPI_UNSIGNED_CHAR |    unsigned char   |
| MPI_UNSIGNED_SHORT | unsigned short int |
|    MPI_UNSIGNED    |    unsigned int    |
|  MPI_UNSIGNED_LONG |  unsigned long int |
|      MPI_FLOAT     |        float       |
|     MPI_DOUBLE     |       double       |
|   MPI_LONG_DOUBLE  |     long double    |
|      MPI_BYTE      |         /          |
|     MPI_PACKED     |         /          |

]

---
layout: false
name: p2p
class: center, middle, inverse

# Point to Point komunikacija

---
layout: true

.section[[Point to Point komunikacija](#sadrzaj)]

---

## Point to Point komunikacija
- Komunikacija dva procesa. Jedan proces ≈°alje poruku, drugi proces prima poruku.
- Funkcije za razmenu poruka.ref[1,2]:

.lcol.medium[

```c
int MPI_Recv(
	void *buf,
	int count,
	MPI_Datatype datatype,
	int source,
	int tag,
	MPI_Comm comm,
	MPI_Status *status);
```
]

.rcol.medium[
```c
int MPI_Send(
	const void *buf,
	int count,
	MPI_Datatype datatype,
	int dest,
	int tag,
	MPI_Comm comm);
```
]
![:scale 45%](img/p2p.gif)

.footer.medium[
   <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Recv.3.php">1. OpenMPI 2.0 MPI_Recv docs</a><br>
   <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Send.3.php">2. OpenMPI 2.0 MPI_Send docs</a>

] 

---

## Primer 2: Point to Point komunikacija <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> <br>‚òõ Primeri/`send_recv.c`</a>

```c
// ...
if (rank == 0) {

	int message = 1;

	printf("Proces %d salje poruku procesu %d.\n", rank, 1);

	MPI_Send(&message, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);

} else if (rank == 1) {

	int message;

	printf("Proces %d treba da primi poruku od procesa %d.\n",rank, 0);

	MPI_Recv(&message, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, NULL);

	printf("Proces %d primio poruku %d od procesa %d.\n", rank, message, 0);
}

// ...
```

---

## Re≈æimi Point-to-Point komunikacije

- P2P komunikacioni re≈æimi slanja poruke:
	- `Synchronous` (MPI_Ssend)- po≈°iljalac ≈°alje zahtev za slanje poruke, nakon ≈°to primalac odgovori poruka se ≈°alje (*handshake protokol*)
	- `Buffered` (MPI_Bsend) - po iniciranju slanja poruka se ≈°alje u bafer odakle je primalac mo≈æe preuzeti
	- `Standard` (MPI_Send) - mo≈æe imati karakteristike buffered ili `synchronous` re≈æima (podrazumevano)
	- `Ready` (MPI_Rsend) - pretpostavlja se da je proces koji prima poruku veƒá ƒçeka na poruku u trenutku iniciranja slanja
- Za prijem poruke postoji samo jedan re≈æim i poruka se smatra primljenom kada je preuzeta i mo≈æe dalje da se koristi.

---

## Tipovi Point-to-Point komunikacije
- Slanje i prijem poruke mogu biti:
	- blokirajuƒái - Ako `MPI_Send` blokirajuƒáa, kontrola toka se neƒáe vratiti pozivaocu funkcije sve dok uslov slanja ne bude ispunjen. Nakon izlaska iz funkcije bafer poruke mo≈æe biti bezbedno prepisan. Ako je `MPI_Recv` blokirajuƒáa kontrola se ne vraƒáa pozivaocu funkcije sve dok poruka ne bude preuzeta (`podrazumevano`).
	- neblokirajuƒái - Iz `MPI_Send`, tj. `MPI_Recv` se izlazi nakon inicijacije slanja, tj. primanja poruke. Kada se pojavi potreba za kori≈°ƒáenjem izvornog odnosno odredi≈°nog bafera, potrebno je prethodno proveriti da li je podatak poslat tj. da li je stigao.

.center[
```c
MPI_{I}[S, B, R]Send(...), MPI_{I}Recv(...)
```
]

---

## Zadatak 2: Ping pong

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Napraviti OpenMPI program implementiran u C programskom jeziku koji simulira igranje ping ponga izmeƒëu dva procesa. Lopticu simulirati promenljivom tipa int. Uveƒáati ovu promenljivu svaki put kada neki od procesa udari lopticu, odnosno, pre nego ≈°to neki od procesa po≈°alje promenljivu drugom procesu i ispisati odgovarajuƒáu poruku.
]
]

--
.message.is-dark[
.message-header[
Primer
]
.message-body[
- Format oƒçekivanog ispisa:
```console
p0 sent ping_pong_count to p1 and incremented it to 1.
p1 received ping_pong_count 1 from p0.
p1 sent ping_pong_count to p0 and incremented it to 2.
```

]
]

--
.message.is-warning[
.message-header[
Info
]
.message-body[
- **Napomene**: 
Pretpostavka je da ƒáe program biti pozvan opcijom `-np 2` i od ovoga se ne mora ≈°tititi.
Ne znaƒçi da program nije ispravan ukoliko ispis na ekranu nije u oƒçekivanom redosledu.
]
]

---

## Zadatak 3: Prsten

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Napisati OpenMPI C program koji prosleƒëuje ≈æeton izmeƒëu procesa po principu prstena. ≈Ωeton je predstavljen brojem -1 i poseduje ga proces ranga 0. Svi procesi osim poslednjeg ≈°alju ≈æeton procesu sa rangom za jedan veƒái od svog. Poslednji proces (proces sa najveƒáim rangom u komunikatoru) ≈æeton prosleƒëuje nazad procesu ranga 0. Nakon ≈°to proces ranga 0 primi ≈æeton, program se zavr≈°ava. Ispisati poruku na standardni izlaz svaki put kada neki od procesa primi ≈æeton.

]
]

--
.message.is-dark[
.message-header[
Primer
]
.message-body[
- Format oƒçekivanog ispisa:
```console
Process 1 received token -1 from process 0
Process 2 received token -1 from process 1
Process 3 received token -1 from process 2
Process 0 received token -1 from process 3
```
]
]

---

layout: false
name: kk
class: center, middle, inverse

# Kolektivna komunikacija

---
layout: true

.section[[Kolektivna komunikacija](#sadrzaj)]

---
## Kolektivna komunikacija
- (eng. *collective communication*)
- Komunikacija **svih** procesa unutar jednog komunikatora.
- Vrste kolektivne komunikacije:
	- Broadcast
	- Scatter
	- Gather
	- AllGather
	- Reduction
	- AllReduction
	- ...

---

## Kolektivna komunikacija: Broadcast

.lcol[
```c
int MPI_Bcast(
	void *buffer,
	int count,
	MPI_Datatype datatype,
	int root,
	MPI_Comm comm);
```
]

.rcol[
![:scale 75%](img/broadcast.png)
]
<br><br><br><br><br><br><br>

- Proces ƒçiji je rank jednak vrednosti root parametra ≈°alje poruku svim ostalim procesima iz komunikatora, ukljuƒçujuƒái i sebe.

---

## Primer 3: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`bcast.c`</a>
```c
int main(int argc, char *argv[]) {
	int rank, root = 0;

	MPI_Init(&argc, &argv);

	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	int token;
	if (rank == root) token = 123;
	MPI_Bcast(&token, 1, MPI_INT, root, MPI_COMM_WORLD);
	printf("Proces %d primio token %d.\n", rank, token);

	MPI_Finalize();
	
	return 0;
}
```

---

## Zadatak 4: Broadcast

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Napisati OpenMPI C implementaciju `MPI_Bcast` funkcije kori≈°ƒáenjem `MPI_Send` i `MPI_Recv` funkcija. Rank procesa koji emituje vrednost ≈æetona se unosi kao argument poziva programa. Vrednost ≈æetona koji se emituje je -1. Nakon ≈°to root proces (proces koji emituje vrednost ≈æetona) po≈°alje ≈æeton ispisati poruku o tome.
- Nakon ≈°to svaki od preostalih procesa primi ≈æeton, ispisati poruku i vrednost primljenog ≈æetona.

]
]

--
.message.is-dark[
.message-header[
Primer
]
.message-body[
- Format oƒçekivanog ispisa:
```console
Proces 0 poslao zeton -1
Proces 1 primio zeton -1
Proces 2 primio zeton -1
Proces 3 primio zeton -1
```
]
]

---

## Zadatak 5: Kolektivna komunikacija nad podskupom komunikatora

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- U kolektivnoj komunikaciji uƒçestvuju svi procesi unutar komunikatora. Meƒëutim, pri pre≈°avanju kompleksnijih problema mo≈æe se pojaviti potreba da se neki podatak po≈°alje samo delu procesa komunikatora. Ustanovili smo da kori≈°ƒáenje metoda kolektivne komunikacije mo≈æe biti efikasnije u odnosu na pojedinaƒçno pozivanje `MPI_Send` i `MPI_Recv` za svaki od procesa u komunikatoru kojima treba proslediti podatak. 
- Kako biste podatak poslali samo delu procesa u nekom komunikatoru kori≈°ƒáenjem kolektivne komunikacije?
]
]

---

## Zadatak 6: Kolektivna komunikacija nad podskupom komunikatora

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- U kolektivnoj komunikaciji uƒçestvuju svi procesi unutar komunikatora. Meƒëutim, pri pre≈°avanju kompleksnijih problema mo≈æe se pojaviti potreba da se neki podatak po≈°alje samo delu procesa komunikatora. Ustanovili smo da kori≈°ƒáenje metoda kolektivne komunikacije mo≈æe biti efikasnije u odnosu na pojedinaƒçno pozivanje `MPI_Send` i `MPI_Recv` za svaki od procesa u komunikatoru kojima treba proslediti podatak. 
- Kako biste podatak poslali samo delu procesa u nekom komunikatoru kori≈°ƒáenjem kolektivne komunikacije?
]
]

.message.is-success[
.message-header[
Odgovor
]
.message-body[
- Napraviti novi komunikator za procese kojima treba poslati podataka i koristiti kolektivnu komunikaciju na nivou novonapravljenog komunikatora.
]
]

---

## Kolektivna komunikacija: Scatter

.lcol[

```c
int MPI_Scatter(
	const void *sendbuf,
	int sendcount,
	MPI_Datatype sendtype,
	void *recvbuf,
	int recvcount,
	MPI_Datatype recvtype,
	int root,
	MPI_Comm comm);
```

]

.rcol[

![:scale 85%](img/scatter.png)

]
<br><br><br><br><br><br><br><br>

- Korenski proces ≈°alje delove podataka procesima iz komunikatora..ref[1]
- Svaki proces dobija "parƒçe" podatka iste veliƒçine.

.footer.medium[
    1. <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Scatter.3.php">MPI_Scatter docs</a>
] 

---

## Primer 4: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`scatter.c`</a>

```c
int main(int argc, char *argv[]) {

	/* ... */

	int *data = NULL, *partial_data = NULL;
	int piecelen = datalen / size;

	if (rank == root) {
		/* inicijalizacija data niza */

	}
	partial_data = (int *) malloc(sizeof(int) * piecelen);

	MPI_Scatter(data, piecelen, MPI_INT, partial_data, piecelen, MPI_INT, root, MPI_COMM_WORLD);

	/* ... */

	return 0;
}
```

---

## Kolektivna komunikacija: Gather

.lcol[

```c
int MPI_Gather(
	const void *sendbuf,
	int sendcount,
	MPI_Datatype sendtype,
	void *recvbuf,
	int recvcount,
	MPI_Datatype recvtype,
	int root,
	MPI_Comm comm);
```

]

.rcol[

![:scale 85%](img/gather.png)

]

<br><br><br><br><br><br><br><br>
- Korenski proces prima podatke od procesa iz komunikatora..ref[1] 
- Svaki proces ≈°alje "parƒçe" podatka iste veliƒçine.

.footer.medium[
    1. <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Gather.3.php">MPI_Gather docs</a>
] 

---

## Primer 5: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`gather.c`</a>
```c
int main(int argc, char *argv[]) {

	int *data = NULL, *partial_data = NULL;
	int piecelen = datalen / size;
	partial_data = (int *) malloc(sizeof(int) * piecelen);

	/* ... */

	if (rank == root)
	data = (int *) malloc(sizeof(int) * datalen);
	
	MPI_Gather(partial_data, piecelen, MPI_INT, data, piecelen, MPI_INT, root, MPI_COMM_WORLD);
	
	/* ... */
	
	return 0;
}
```

---

## Zadatak 7: Raƒçunanje srednje vrednosti

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Napraviti OpenMPI C program koji raƒçuna srednju vrednost elemenata niza u vi≈°e procesa kori≈°ƒáenjem funkcija `MPI_Scatter` i `MPI_Gather`. Program napisati tako da:
	- Korenski proces inicijalizuje niz du≈æine n nasumiƒçno izgenerisanim celim brojevima. Du≈æina niza mora biti deljiva brojem pokrenutih procesa.
	- Razdeliti izgenerisani niz na jednake delove izmeƒëu svih procesa.
	- Svaki proces treba da izraƒçuna sumu elemenata niza koji su mu prosleƒëeni.
	- Nakon ≈°to su sve parcijalne sume sraƒçunate, prebacuju se nazad korenskom procesu koji od parcijalnih suma pravi konaƒçnu sumu koju deli ukupnim brojem elemenata i ispisuje srednju vrednost niza.
]
]

---

## Kolektivna komunikacija: AllGather

.lcol[

```c
int MPI_Allgather(
	const void *sendbuf,
	int sendcount,
	MPI_Datatype sendtype,
	void *recvbuf,
	int recvcount,
	MPI_Datatype recvtype,
	MPI_Comm comm);
```

]

.rcol[

![:scale 60%](img/allgather.png)

]

<br><br><br><br><br><br><br><br><br>

- Efektivno poziv `MPI_Gather` praƒáen `MPI_Bcast` pozivom..ref[1]

.footer.medium[
    1. <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Allgather.3.php">MPI_Allgather docs</a>
] 

---

## Primer 6: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`allgather.c`</a>
```c
int main(int argc, char *argv[]) {

	/* ... */

	int *data = (int *) malloc(sizeof(int) * size);

	int token = rank;
	MPI_Allgather(&token, 1, MPI_INT, data, 1, MPI_INT, MPI_COMM_WORLD);

	free(data);
	
	/* ... */
	
	return 0;
}
```

---

## Kolektivna komunikacija: Reduce

.lcol[

```c
int MPI_Reduce(
	const void *sendbuf,
	void *recvbuf,
	int count,
	MPI_Datatype datatype,
	MPI_Op op,
	int root,
	MPI_Comm comm);
```

]

.rcol[

![:scale 90%](img/reduce.png)

]

<br><br><br><br><br><br><br><br><br>

- Procesi unutar komunikatora ≈°alju podatke korenskom procesu koji vr≈°i redukciju nad podacima zadatom funkcijom (npr. `MPI_SUM`, `MPI_AND`...)..ref[1]

.footer.medium[
    1. <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Reduce.3.php">MPI_Reduce docs</a>
] 

---

## Primer 7: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`reduce.c`</a>

```c
int main(int argc, char *argv[]) {
	/* ... */

	int token = rank, result;
	MPI_Reduce(&token, &result, 1, MPI_INT, MPI_SUM, root, MPI_COMM_WORLD);

	printf("Proces %d: result = %d.\n", rank, result);

	MPI_Finalize();
	
	return 0;
}
```

---

## Zadatak 8: Raƒçunanje srednje vrednosti 2

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Modifikovati zadatak koji raƒçuna srednju vrednost elemenata niza tako da se u odgovarajuƒáem koraku koristi funkcija `MPI_Reduce`.
]
]

---

## Kolektivna komunikacija: AllReduce

.lcol[

```c
int MPI_Allreduce(
	const void *sendbuf,
	void *recvbuf,
	int count,
	MPI_Datatype datatype,
	MPI_Op op,
	MPI_Comm comm);
```

]

.rcol[

![:scale 90%](img/allreduce.png)

]

<br><br><br><br><br><br><br><br><br>

- Efektivno poziv `MPI_Reduce` praƒáen `MPI_Bcast` pozivom.

.footer.medium[
    1. <a target="_blank" rel="noopener noreferrer" href="https://www.open-mpi.org/doc/v2.0/man3/MPI_Allreduce.3.php">MPI_Allreduce docs</a>
] 

---

## Primer 8: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z3-openMPI/#table-of-contents"> ‚òõ Primeri/`allreduce.c`</a>

```c
int main(int argc, char *argv[]) {
	/* ... */

	int token = rank, result;
	MPI_Allreduce(&token, &result, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

	printf("Proces %d: result = %d.\n", rank, result);

	/* ... */
	
	return 0;
}
```

---

## Zadatak 9: Mno≈æenje matrice i vektora - domaƒái

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Napisati OpenMPI C program za mno≈æenje kvadratne matrice i vektora. Ulazna matrica i vektor sadr≈æe razlomljene brojeve u jednostrukoj preciznosti i podrazumeva se da ƒáe dimenzije matrice i vektora biti odgovarajuƒáe. Ulazni podaci za zadatak su izgenerisani i dati u h5 formatu. Takoƒëe, dat je kostur re≈°enja sa primerima kako uƒçitati matricu/vektor iz h5 datoteke i ispisati ih na standardni izlaz (direktorijum MatrixVectorMultiplication). Za detalje oko kompajliranja i pokretanja re≈°enja pogledati README.md datoteku.
- Implementirati:
  - Sekvencijalni algoritam za mno≈æenje matrice i vektora. Meriti vreme izvr≈°avanja i ispisati ga na standardni izlaz.
  - OpenMPI C algoritam za mno≈æenje matrice i vektora. Meriti vreme izvr≈°avanja i ispisati ga na standardni izlaz. Ostaviti moguƒánost da se na standardni izlaz ispi≈°e i rezultat raƒçunanja
]
]

---

## Korisni materijali

- [MPI standard dokumentacija](https://www.mpi-forum.org/docs/)
- [OpenMPI dokumentacija](https://www.open-mpi.org/doc/)
- Peter S. Pacheco "Parallel Programming with MPI"
- Victor Eijkhout "Parallel Computing" (besplatna onlajn verzija knjige)
- [MPI tutorijal](http://mpitutorial.com/)

--

class: center, middle, theend, hide-text
layout: false
background-image: url(../theend.gif)

</textarea>
	<script src="../remark-latest.min.js"></script>
	<script>
		// https://github.com/gnab/remark/issues/72
		        remark.macros.scale = function (percentage) {
		            var url = this;
		            return '<div class="center"><img src="'
		                 + url + '" style="width: ' + percentage + '" /></div>';
		        };
		        var slideshow = remark.create({
		                    highlightLanguage: 'python',
		                    // highlightStyle: 'obsidian',
		                    highlightStyle: 'github',
		                    highlightLines: true,
		                    countIncrementalSlides: false,
		                    navigation: {
		                      // Enable or disable navigating using scroll
		                      // Default: true
		                      // Alternatives: false
		                      scroll: false,
		
		                      //click: true,
		                    }
		                });
	</script>
	<script src="../mermaid.min.js"></script>
	<script>
		mermaid.initialize({startOnLoad:true});
	</script></body>

</html>