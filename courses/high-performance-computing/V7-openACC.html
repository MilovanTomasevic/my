<!DOCTYPE html>
<html>

<head>
	<title>[High-performance computing (HPC)](/courses/#table-of-contents)</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="../remarkslides.css">
	<!-- MathJax‚Ñ¢ -->
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async>
	</script>
	<!-- mermaid dijagram -->
	<link rel="stylesheet2" href="../mermaid.min.css">
	<script>
		mermaid.initialize({startOnLoad:true});
	</script>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127734928-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		      function gtag(){dataLayer.push(arguments);}
		      gtag('js', new Date());
		
		      gtag('config', 'UA-127734928-1');
	</script>
	<!-- google analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		      ga('create', 'UA-127734928-1', 'auto');
		      ga('send', 'pageview');
	</script>
</head>

<body>
	<textarea id="source">class: center, middle

## [High-performance computing (HPC)](/courses/#table-of-contents)
### V7-openACC


.author[[dr. Milovan Toma≈°eviƒá](https://www.milovantomasevic.com/resume/)]

.small[[Fakulteta za informacijske ≈°tudije v Novem mestu (FI≈†)](https://www.fis.unm.si/en/)</br>![:scale 10%](../fis/fis.png) .small[ [üåê‚ûô milovan.tomasevic.fis.unm.si](http://milovan.tomasevic.fis.unm.si)</br> [üìß‚ûô milovan.tomasevic@fis.unm.si](mailto:milovan.tomasevic@fis.unm.si)]]



.created[08.03.2019 u 17:57]


---


name: sadrzaj

# Sadr≈æaj

- [OpenACC](#acc)
- [kernels direktiva](#kd)
- [parallel direktiva](#pd)
- [loop direktiva](#ld)
- [Model](#model)
- [data direktiva](#dd)
- [Zadaci](#zad)
- [OpenACC i CUDA](#cuda)

---
name: acc
class: center, middle, inverse

# OpenACC

---
layout: true

.section[[OpenACC](#sadrzaj)]

---
## ≈†ta je OpenACC

- API za prebacivanje izvr≈°avanja delova koda na **akcelerator**.
- Obuhvata:
	- direktive (`pragma acc <direktiva>`)
	- promenljive okru≈æenja (eng. *runtime environment variables*)
	- biblioteƒçke rutine (eng. *library routines*)
- Podr≈°ka za C, C++ i Fortran.
- Konceptualno veoma sliƒçan OpenMP.

---

## Ciljna arhitektura

- Akceleratori.

.lcol[

![:scale 75%](img/acc2.png)
]

.rcol[

![:scale 110%](img/acc.jpg)

]

<br><br><br><br><br><br><br><br><br>
- U laboratoriji ƒáemo kao akcelerator koristiti **Nvidia Quadro** grafiƒçke kartice.

---

## OpenACC kompajleri

![:scale 90%](img/compile.png)

- Na ve≈æbama ƒáemo koristiti GNU GCC kompajler.

.footer.medium[
[Izvor - OpenACC](https://www.openacc.org/tools)
] 

---

## Kompajliranje OpenACC programa

- Pozicionirati se u direktorijum u kojem se nalazi datoteka sa OpenACC kodom i u terminalu uneti:
```console
gcc -o izvrsna_dat izvorna_dat.c -fopenacc
```

- Za pokretanje programa, pozicionirati se u direktorijum u kojem je izvr≈°na datoteka i uneti `./izvrsna_dat`.
- Ukoliko program poziva neku od OpenACC funkcija (naziv poƒçinje sa acc_), u izvornu datoteku je potrebno dodati i
```c
#include <openacc.h>
```

---

## Terminologija

- **Domaƒáin** (eng. *Host*) - centralna procesna jedinica sa svojom hijerarhijom memorije.
- **Akselerator** (eng. *Accelerator* ili *Device*) - akseleratorski ureƒëaj, npr. grafiƒçka kartica.
- **Paralelni region** - Deo koda obele≈æen za izvr≈°avanje na akceleratorskom ureƒëaju sa pridru≈æenim strukturama podataka. Obuhvata regione koda obele≈æene `parallel` i `kernels` direktivama (drugaƒçije ƒáe se zvati i raƒçunski regioni).

---

## OpenACC model izvr≈°avanja

![:scale 50%](img/accModel.jpg)

.center[
`Figure`: Konceptualna arhitektura akseleratora.ref[*]
]

OpenACC podr≈æava tri nivoa paralelizma: `gang, worker, vector`

.footer.medium[
  [* Link](https://www.sciencedirect.com/topics/computer-science/target-machine)
]

---

## OpenACC model izvr≈°avanja

Op≈°ti format OpenACC direktive:

```c
#pragma acc <directive> [clause-list] new-line
structured block
```
- Direktive za obele≈æavanje paralelnog koda:
	- `kernels`
	- `parallel`

---
layout: false
name: kd
class: center, middle, inverse

# kernels direktiva

---
layout: true
.section[[kernels direktiva](#sadrzaj)]

---

## kernels direktiva

- Oznaƒçava deo koda koji mo≈æe biti preveden za izvr≈°avanje na akceleratoru pravljenjem jednog ili vi≈°e kernela. 
- Kompajler odluƒçuje `≈°ta` ƒáe i `kako` ƒáe paralelizovati.
```c
#pragma acc kernels [clause-list] new-line
structured block
```
- Neke od klauzula (parametri nisu navedeni):

.lcol[

- async
- copyin
- wait
]

.rcol[
- copyout
- copy
- ...
]

---

## Primer 1: kernel.c

```c
int main() {

	/* ... */
	#pragma acc kernels
	{
		for(i = 0; i < MATRIX_SIZE; i++)
			for(j = 0; j < MATRIX_SIZE; j++)
				randomMatrix[i * MATRIX_SIZE + j] =
				randomMatrix[i * MATRIX_SIZE + j] * 2;
	}

	return 0;
}

```

---

## Primer 2: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z7-openACC/#table-of-contents"> ‚òõ Primeri/`ptraliasing.c`</a>

.message.is-dark[
.message-header[
Primer
]
.message-body[
```c
void assign(int *a, int *b, int size) {
	#pragma acc kernels
	{
		for (int i = 0; i < size - 1; i++)
			a[i] = b[i + 1];
	}
}
``` 
]
]

--
.message.is-info[
.message-header[
Zadatak
]
.message-body[
- **Pitanje**: Kada se koristi kernels direktiva, kompajler pronalazi delove koda koji su bezbedni za paralelizaciju, odnosno, u kojima nema zavisnosti meƒëu podacima. ≈†ta mislite, da li bi OpenACC kompajler preveo ovo u kod za paralelno izvr≈°avanje?
]
]

---

layout: false
name: pd
class: center, middle, inverse

# parallel direktiva

---
layout: true
.section[[parallel direktiva](#sadrzaj)]

---

## parallel direktiva

- Oznaƒçava deo koda koji ƒáe biti preveden za izvr≈°avanje na akceleratoru. 
Kompajler odreƒëuje **kako** ƒáe segment koda biti paralelizovan. 
Podrazumevano izvr≈°avanje kreƒáe u `gang-redundant` re≈æimu.
```C
#pragma acc parallel [clause-list] new-line
structured block
```
Neke od klauzula (parametri nisu navedeni):

.lcol[

- async
- wait
- num_gangs
- num_workers
- vector_length
]

.rcol[
- reduction
- copy
- copyin
- copyout
- ...
]

---

## Primer 3: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z7-openACC/#table-of-contents"> ‚òõ Primeri/`parallel.c`</a>

.message.is-dark[
.message-header[
Primer
]
.message-body[
```c
#include <openacc.h>

int main() {
	float *values = (float *) malloc(sizeof(float) * size);

	#pragma acc parallel
	for (int i = 0; i < 1024; i++)
		values[i] = 1.f;
	free(values);

	return 0;
}
```
]
]

--
.message.is-info[
.message-header[
Zadatak
]
.message-body[
- **Pitanje**: Koliko puta ƒáe svakom polju value niza biti dodeljena vrednost?
]
]

---

## parallel klauzule

- `async` - Nit koja je nai≈°la na parallel ili kernels direktivu (lokalna nit) mo≈æe da nastavi izvr≈°avanje koda koji sledi iza paralelnog regiona bez ƒçekanja da ureƒëaj zavr≈°i svoj posao.
- `wait` - Kada naiƒëe na ovu klauzulu, lokalna nit ƒçeka.
- `num_gangs(int-exp)` - Broj `gang`-ova koji izvr≈°avaju paralelni region.
- `num_workers(int-exp)` - Broj radnika unutar `gang`-a.
- `vector_length(int-exp)` - Du≈æina vektora koja se koristi za SIMD operacije.
- `reduction(op:var-list)` - Pravi lokalnu kopiju promenljive i inicijalizuje je. Na kraju paralelnog regiona se lokalne kopije redukuju.
- `copy, copyin, copyout`

---

layout: false
name: ld
class: center, middle, inverse

# loop direktiva

---
layout: true
.section[[loop direktiva](#sadrzaj)]

---

## loop direktiva

- Daje kompajleru dodatne informacije o tome kako da paralelizuje petlju na koju se odnosi direktiva. Mo≈æe biti unutar `parallel` ili `kernels` direktiva.

```c
  #pragma acc loop [clause-list] new-line
    for loop
```
- Kombinovane konstrukcije:

```c
  #pragma acc parallel loop [clause-list] new-line
    for loop
```

```c
  #pragma acc kernels loop [clause-list] new-line
    for loop
```

---

## loop klauzule
- Klauzule za optimizaciju izvr≈°avanja:
	- `gang` - Particioni≈°e iteracije izmeƒëu `gang`-ova. Prevodi izvr≈°avanje iz `gang-redundant` u `gang-partitioned` re≈æim. U sluƒçaju ugnje≈ædenih petlji, spoljna mora biti `gang` petlja.
	- `worker` - Patricioni≈°e iteracije izmeƒëu `worker`-a. Prevodi izvr≈°avanje iz `worker-single` u `worker-partitioned` re≈æim. U sluƒçaju ugnje≈ædenih petlji, bilo koja unutra≈°nja petlja, osim one najugnje≈ædenije, mo≈æe biti `worker` petlja.
	- `vector` - Vektorizacija petlje (SIMD ili SIMT ). U sluƒçaju ugnje≈ædenih petlji, najugnje≈ædenija je vector petlja.
	- `seq` - Petlja ƒáe se izvr≈°iti sekvencijalno bez obzira na potencijalne optimizacije koje je kompajler prona≈°ao. U suƒçaju ugnje≈ædenih petlji, mo≈æe biti na bilo kom nivou. 
- *Optimizacijom petlji se gubi na portabilnosti programa.*

---

##loop klauzule

- Ostale klauzule:
	- private
	- reduction
	- independent - Signalizira kompajleru da nema zavisnosti podataka izmeƒëu iteracija petlje.
	- ...

---

## Primer 4: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z7-openACC/#table-of-contents"> ‚òõ Primeri/`parallelloop.c`</a>

```c
int main() {

	/* ... */

	#pragma acc parallel loop gang
	for (int i=0; i<N; i++)
		#pragma acc loop vector
		for (int j=0; j<M; j++)
			A[i * N + j] = 1.f;

	return 0;
}
```

---
layout: false
name: model
class: center, middle, inverse

# Model

---
layout: true
.section[[Model](#sadrzaj)]

---

## Model podataka i utican na na performanse

.lcol[

![:scale 95%](img/modelAcc.png)
]

.rcol[

![](img/modelAcc2.png)

]
<br><br><br><br><br><br><br><br><br><br><br>

- Optimizacija kernela bez optimizacije prenosa podataka obiƒçno ne vodi pobolj≈°anju performansi izvr≈°avanja programa!

.footer.medium[
	Izvor: [OpenACC Programming and Best Practices Guide](https://www.openacc.org/sites/default/files/inline-files/OpenACC_Programming_Guide_0.pdf)
] 

---

## Upravljanje podacima

- Prenos podataka izmeƒëu domaƒáina i ureƒëaja je moguƒáe kontrolisati na vi≈°e naƒçina:
	- Bez bilo kakvog specificiranja pona≈°anja, kompajler ƒáe sam odrediti kada i koje podatke treba preneti sa domaƒáina na ureƒëaj ili obrnuto.
	- Modifikovanjem pona≈°anja `parallel` i `kernels` odgovarajuƒáim klauzulama za rad sa podacima (npr. `copy, copyin, copyout`...). Modifikacije va≈æe za paralelni region nad kojim su primenjene klauzule za modfikaciju.
	- Kori≈°ƒáenjem `data` direktive.
	- Kori≈°ƒáenjem `data enter` i `data exit` direktiva (uglavnom za objektno programiranje).

---

layout: false
name: dd
class: center, middle, inverse

# data direktiva

---
layout: true
.section[[data direktiva](#sadrzaj)]

---

## data direktiva

- Defini≈°e blok koda u kojem se klauzulama kontroli≈°e prenos podataka na relaciji domaƒáin ureƒëaj.
```c
#pragma acc data [clause-list] new-line
structured block
```
	- copy
	- copyin
	- copyout
	- create
	- present

---

## Primer 5: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z7-openACC/#table-of-contents"> ‚òõ Primeri/`data.c`</a>

```c
int main() {
	/* ... */
	#pragma acc data
	{
		#pragma acc parallel loop
		for (int i=0; i<N; i++) {
			y[i] = 0.0f;
			x[i] = (float)(i+1);
		}
		#pragma acc parallel loop
		for (int i=0; i<N; i++) {
			y[i] = 2.0f * x[i] + y[i];
		}
	}
	/* ... */
}
```

---

## Klauzule
- `copy(var-list)` - Alocira prostor za promenljive na ureƒëaju, kopira vrednosti sa domaƒáina na ureƒëaj i sa ureƒëaja nazad na domaƒáina kada se zavr≈°i blok podataka (ili `parallel` i `kernels` blok ako klauzula stoji uz njih)
- `copyin(var-list)` - Alocira prostor za promenljive na ureƒëaju i kopira vrednosti sa domaƒáina na ureƒëaj. Po zavr≈°etku bloka ne prenosi vrednosti nazad na domaƒáina.
- `copyout(var-list)` - Alocira prostor za promenljive na ureƒëaju bez inicijalizacije podacima sa domaƒáina. Po zavr≈°etku bloka, podaci se prenose sa ureƒëaja na domaƒáina.
- `create(var-list)` - Alocira prostor za promenljive na ureƒëaju bez inicijalizacije. Vrednosti promenljivih se na kraju bloka ne prebacuju na domaƒáina.
- `present(var-list)` - Oznaƒçava da su promenljive prisutne u memoriji ureƒëaja.

---

## OpenACC promenljive okru≈æenja

- GNU GCC kompajler:
	- `ACC_DEVICE_TYPE` (standard)
	- `ACC_DEVICE_NUM` (standard)
	- `ACC_PROF` (standard)
	- `GOPMP_OPENACC_DIM` (gcc)
	- `GOMP_DEBUG` (gcc)

---

layout: false
name: zad
class: center, middle, inverse

# Zadaci

---
layout: true
.section[[Zadaci](#sadrzaj)]

---

## Zadatak 1: Raƒçunanje broja œÄ

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Modifikovati dati sekvencijalni program za raƒçunanje vrednosti broja œÄ kori≈°ƒáenjem OpenACC direktiva. Koristiti NVIDIA grafiƒçku karticu kao akcelerator (GNU GCC trenutno ne podr≈æava Radeon kartice). 
- Meriti izvr≈°avanje sekvencijalnog i implementiranog ubrzanog programa.
]
]

--
.message.is-warning[
.message-header[
Info
]
.message-body[
- **Napomena**: Zadatak svakako implementirati i u sluƒçaju da na raƒçunaru nemate dostupnu NVIDIA grafiƒçku karticu.
]
]

---

## Zadatak 2: Raƒçunanje Jakobijana

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Modifikovati dati sekvencijalni program za raƒçunanje Jakobijana.
- Osnovnu verziju programa u C++ programskom jeziku skinuti sa
- Githab naloga OpenACCUserGroup.Koristiti NVIDIA grafiƒçku karticu kao akcelerator (GNU GCC trenutno ne podr≈æava Radeon kartice). 
- Meriti izvr≈°avanje sekvencijalnog i implementiranog ubrzanog programa.
]
]

--
.message.is-warning[
.message-header[
Info
]
.message-body[
- **Napomena**: Zadatak svakako implementirati i u sluƒçaju da na raƒçunaru nemate dostupnu NVIDIA grafiƒçku karticu.
]
]

---

## Saveti za inkrementalno portovanje sekvencijalnog u OpenACC kod

1. Identifikovati paralelizam petlji. Paralelizovati deo po deo sekvencijalnog koda pri tom kontroli≈°uƒái korektnost izvr≈°avanja programa. Nastaviti sa ovim tipom optimizacije bez obzira na to da li se vreme izvr≈°avanja poveƒáava.

2. Optimizovati prenos podataka. Preklopiti prenos podataka sa raƒçunanjem, ukloniti nepotrebna kopiranja, a≈æuriranja promenljivih, itd...

3. Paralelizovane petlje optimizovati za ciljnu arhitekturu kori≈°ƒáenjem klauzula.

.footer.medium[
Izvor: [OpenACC Programming and Best Practices Guide](https://www.openacc.org/sites/default/files/inline-files/OpenACC_Programming_Guide_0.pdf)
]

---

layout: false
name: cuda
class: center, middle, inverse

# OpenACC i CUDA

---
layout: true
.section[[OpenACC i CUDA](#sadrzaj)]

---
## CUDA ponavljanje

- `CUDA` (eng. *Compute Unified Device Architecture*) - platrofma za paralelno programiranje na NVIDIA grafiƒçkim karticama.
- Mapiranje OpenACC na CUDA termine:

|            **OpenACC**           |           **CUDA**          |
|:--------------------------------:|:---------------------------:|
|       Domaƒáin (eng. *Host*)      |    Domaƒáin (eng. *Host*)    |
| Akcelerator (eng. *Accelerator*) |    Ureƒëaj (eng. *Device*)   |
|   Paralelni ili raƒçunski region  | Jedan ili vi≈°e CUDA kernela |

- U OpenACC kod je na vi≈°em nivou abstrakcije u odnosu na CUDA kod i mo≈æe se prevesti za izvr≈°avanje na GPU.

---

## Arhitektura CUDA grafiƒçke kartice

- Streaming Multiprocessors (SM) & Kuda jezgra
- Veliki broj hardverskih niti ƒçini grafiƒçke kartice pogodnim za probleme za izra≈æenim SIMD paralelizmom.

.lcol[

![:scale 75%](img/cudaM.png)
]

.rcol[

![:scale 65%](img/cuda.jpg)
]

---

## Memorijska hijerarhija CUDA grafiƒçke kartice

![:scale 55%](img/cudaMH.png)

- **Globalna memorija, L2 ke≈°** - mogu da joj pristupe svi SM.
- **Deljena memorija, L1 ke≈°** - mogu joj pristupiti sva jezgra unutar jednog SM.
- **Registri** - pristup na nivou jezgra.
- Konstantna memorija, memorija tekstura

---

## CUDA model izvr≈°avanja

.lcol[

![:scale 85%](img/cudaMI.png)

]

.rcol[

- Nit
- Blok niti (eng. *thread block*) sadr≈æi jednu ili vi≈°e niti
- Osnova (eng. *warp*) - sadr≈æi jednu ili vi≈°e niti iz istog bloka, blok je podeljen na jednu ili vi≈°e osnova
- Mre≈æa niti (eng. *grid*) sadr≈æi jedan ili vi≈°e blokova niti

]

---

## OpenACC CUDA mapiranja

.center[

| **CUDA logiƒçki** | **OpenACC logiƒçki** | **CUDA fiziƒçki nivo** |
|:----------------:|:-------------------:|:---------------------:|
|    Mre≈æa niti    |    vi≈°e gang -ova   |   svi SM na kartici   |
|     Blok niti    |         gang        |           SM          |
|       warp       |        worker       |           SM          |
|     CUDA nit     |        vector       |      CUDA jezgro      |

]

- Mapiranje pojmova CUDA modela izvr≈°avanja (prva kolona) na OpenACC model izvr≈°avanja (druga kolona) i na fiziƒçke komponente GPU koja podr≈æava CUDA tehnologiju.

---

## Tehnike za ubrzavanje CUDA programa

- Preporuke za ubrzanje izvr≈°avanja CUDA programa:
	- Ukoliko je moguƒáe, CUDA niti treba da pristupaju uzastopnim lokacijama globalne memorije (eng. *coalesced access*).
	- Izbeƒái divergenciju izvr≈°avanja niti unutar jedne osnove.
	- Podatke koji se ƒçesto koriste prebaciti u br≈æu memoriju u odnosu na globalnu (`cache direktiva`).
	- Optimizovati prenos podataka u/iz globalne memorije grafiƒçke kartice (`data direktiva`).
	- ... 

--

.message.is-warning[
.message-header[
Info
]
.message-body[
- **Preporuƒçeno ƒçitanje**: Programming Massively Parallel Processors: A Hands-on Approach, David B. Kirk and Wen-mei W. Hwu, poglavlje 6 Performance Considerations
]
]

---

## Primer 6: <a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z7-openACC/#table-of-contents"> ‚òõ Primeri/`matrixop.c`</a>

```c
int main(int argc, char *argv[]) {
	int *randomMatrix =
	(int *) calloc(MSIZE * MSIZE * sizeof(int));

	#pragma acc kernels
	{
		for(i = 0; i < MSIZE; i++) {
			for(j = 0; j < MSIZE; j++) {
				randomMatrix[j * MSIZE + i] =
				randomMatrix[j * MSIZE + i] + 2;
			}
		}
	}
}
```

---

## Primer 7: <br><a target="_blank" rel="noopener noreferrer" href="/courses/hpc-z7-openACC/#table-of-contents"> ‚òõ Primeri/`matrixop-coalesced.c`</a>

```c
int main(int argc, char *argv[]) {
	int *randomMatrix =
	(int *) calloc(MSIZE * MSIZE * sizeof(int));

	#pragma acc kernels
	{
		for(int i = 0; i < MSIZE; i++) {
			for(int j = 0; j < MSIZE; j++) {
				randomMatrix[i * MSIZE + j] =
				randomMatrix[i * MSIZE + j] + 2;
			}
		}
	}
}
```

---

## Pristup elementima matrice

- Pristup lokacijama koje nisu uzastopne

![:scale 65%](img/m1.png)

- Pristup uzastopnim lokacijama

![:scale 65%](img/m2.png)

.attention[
**Pretpostavka**: Svaki element matrice obraƒëuje jedna CUDA nit.
]

---

## matrixop.c Visual Profiler

![:scale 75%](img/vp.png)
---

## matrixop-coalesced.c Visual Profiler

![:scale 75%](img/vp2.png)

---

## Divergencija pri izvr≈°avanju niti

- Ukoliko razliƒçite niti unutar iste osnove imaju razliƒçite tragove izvr≈°avanja, izvr≈°avanje grupa niti sa razliƒçitim tragovima unutar osnove se sekvencijalizuje.
- Do divergencije u izvr≈°avanju mogu dovesti naredbe za kontrolu toka izvr≈°avanja `if-else, switch, do, for, while`.

--

.message.is-warning[
.message-header[
Info
]
.message-body[
- **Videti**: CUDA C Best Practices Guide - Branching and Divergence.
]
]

---

## Neki radovi na temu OpenACC, CUDA i OpenCL

- [A Comprehensive Performance Comparison of CUDA and OpenCL](https://ieeexplore.ieee.org/document/6047190)
- [CUDA vs OpenACC: Performance Case Studies with Kernel Benchmarks and a Memory-Bound CFD Application](https://ieeexplore.ieee.org/document/6546071)
- [An in-depth evaluation of GCC‚Äôs OpenACC implementation on Cray systems](https://cug.org/proceedings/cug2017_proceedings/includes/files/pap174s2-file1.pdf)
- [OpenACC cache Directive: Opportunities and Optimizations](https://ieeexplore.ieee.org/document/7836580)

---

## Zadatak 3: Mno≈æenje matrica

.message.is-info[
.message-header[
Zadatak
]
.message-body[
- Implementirati OpenACC C program za mno≈æenje dve kvadratne matrice. 
- Kao ulazne matrice koristiti matrice u hdf5 formatu sa prethodnih ve≈æbi.
]
]

--
.message.is-warning[
.message-header[
Info
]
.message-body[
- **Napomene**:
- Saƒçuvati rezultat mno≈æenja matrica 3x3 ili rezultat ispisati na konzolu.
- Meriti vreme izvr≈°avanja programa i ispisati ga na standardni izlaz (za primer merenja pogledati matrixop.c datoteku u primerima).
- Opciono uporediti vremena izvr≈°avanja implementiranog OpenACC re≈°enja prevedenog za izvr≈°avanje na GPU sa ekvivalentnim CUDA re≈°enjima (direktorijum Samples u CudaToolkit-u ima implementiran primer mno≈æenja dve matrice bez i sa kori≈°ƒáenjem optimizovane cublas biblioteke (direktorijumi cudaMatMul i cudaMatMulCUBLAS).
]
]

---

## Zadatak 3: Mno≈æenje matrica - kompajliranje i pokretanje zadatka

.message.is-warning[
.message-header[
Info
]
.message-body[
- **GNU GCC 7**
- Za prevoƒëenje OpenACC koda za izvr≈°avanje na domaƒáinu:
```console
gcc -fopenacc <izvorna_datoteka>
```
- Za prevoƒëenje OpenACC koda za izvr≈°avanje na NVIDIA GPU:
```console
gcc -fopenacc -foffload=nvptx-none <izvorna_datoteka>
```
- Da bi ovo radilo, neophodno je prvo instalirati paket
`gcc-7-offload-nvptx` *iz repzitorijuma*.

- Pokretanje programa: `./<izvrsna_datoteka>`
- Svi programi koji se izvr≈°avaju na NVIDIA GPU kartici se mogu pratiti pozivom alata `nvidia-smi -l 1`, ≈°to ƒáe osve≈æavati listu procesa koji koriste GPU na svaku sekundu.
]
]

---

## Zadatak 3: Mno≈æenje matrica - kompajliranje i pokretanje zadatka

.message.is-warning[
.message-header[
Info
]
.message-body[
- **PGCC 18.10**
- Za prevoƒëenje OpenACC koda za izvr≈°avanje na domaƒáinu:
```console
pgcc -acc -ta=host <izvorna_datoteka>
```
- Za prevoƒëenje OpenACC koda za izvr≈°avanje na NVIDIA GPU:
```console
pgcc -acc -ta=tesla -Minfo <izvorna_datoteka>.
```
- Pokretanje programa: `./<izvrsna_datoteka>`

- Svi programi koji se izvr≈°avaju na NVIDIA GPU kartici se mogu pratiti pozivom alata nvidia-smi -l 1, ≈°to ƒáe osve≈æavati listu procesa koji koriste GPU na svaku sekundu.
]
]

---
## Literatura

- Tekstualni materijali:
	- [OpenACC Programming and Best Practices Guide](https://www.openacc.org/sites/default/files/inline-files/OpenACC_Programming_Guide_0.pdf)
	- [OpenACC Specification 2.5](https://www.openacc.org/sites/default/files/inline-files/OpenACC_2pt5.pdf)
	- [GNU GCC OpenACC Wiki](https://gcc.gnu.org/wiki/OpenACC)
	- David B. Kirk, Wen-mei W. Hwu, Programming Massively Parallel Processors, A Hands on Approach, 2nd edition, 2012
	- [Advanced OpenACC](http://videolectures.net/site/normal_dl/tag=1058329/ihpcss2016_urbanic_advanced_openACC_01.pdf)
- Video tutorijali:
	- [Introduction to Parallel Programming with OpenACC](https://www.youtube.com/playlist?list=PLx_s9Cz7_T429SF7gBGJ51iiZoEWYVvkq)
	- [Advanced OpenACC](http://videolectures.net/ihpcss2016_urbanic_advanced_openACC/)

--

class: center, middle, theend, hide-text
layout: false
background-image: url(../theend.gif)

</textarea>
	<script src="../remark-latest.min.js"></script>
	<script>
		// https://github.com/gnab/remark/issues/72
		        remark.macros.scale = function (percentage) {
		            var url = this;
		            return '<div class="center"><img src="'
		                 + url + '" style="width: ' + percentage + '" /></div>';
		        };
		        var slideshow = remark.create({
		                    highlightLanguage: 'python',
		                    // highlightStyle: 'obsidian',
		                    highlightStyle: 'github',
		                    highlightLines: true,
		                    countIncrementalSlides: false,
		                    navigation: {
		                      // Enable or disable navigating using scroll
		                      // Default: true
		                      // Alternatives: false
		                      scroll: false,
		
		                      //click: true,
		                    }
		                });
	</script>
	<script src="../mermaid.min.js"></script>
	<script>
		mermaid.initialize({startOnLoad:true});
	</script></body>

</html>